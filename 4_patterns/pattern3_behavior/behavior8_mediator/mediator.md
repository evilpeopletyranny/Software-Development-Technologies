# Mediator

## Посредник

**Паттерн Посредник (Mediator)** — это поведенческий паттерн проектирования, который определяет объект-посредник для
инкапсуляции взаимодействий между множеством объектов. Посредник способствует слабой связанности, удерживая объекты от
необходимости явно ссылаться друг на друга, что упрощает сопровождение и расширение системы.

#### Основная идея

Вместо того чтобы объекты взаимодействовали напрямую друг с другом, они общаются через посредника. Посредник управляет
логикой взаимодействия, что позволяет изменять и расширять взаимодействия без изменения самих объектов.

#### Применение

Паттерн Посредник рекомендуется использовать в следующих случаях:

- **Много взаимосвязанных классов:** Когда классы взаимодействуют между собой, создавая сложную сеть зависимостей.
- **Снижение связанности:** Когда необходимо уменьшить количество прямых зависимостей между классами.
- **Централизация управления взаимодействиями:** Когда нужно централизовать логику взаимодействия для упрощения
  сопровождения и расширения системы.
- **Гибкость в изменении взаимодействий:** Когда требуется легко менять или добавлять новые виды взаимодействий между
  объектами.

### Реализация

1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например,
   чтобы повторно использовать их код в другой программе.
2. Создайте общий интерфейс Посредников и опишите в нём методы для взаимодействия с Компонентами. В простейшем случае
   достаточно одного метода для получения оповещений от компонентов.
   Этот интерфейс необходим, если вы хотите повторно
   использовать классы компонентов для других задач. В этом
   случае, всё, что нужно сделать — это создать новый класс
   конкретного посредника.
3. Реализуйте этот интерфейс в классе Конкретного посредника. Поместите в него поля, которые будут содержать ссылки на
   все объекты компонентов.
4. Вы можете пойти дальше и переместить код создания компонентов в класс Конкретного посредника, превратив его в фабрику
5. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобней всего установить, подавая
   посредника в параметры конструктора компонентов.
6. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, а не методы других компонентов. С
   другой стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение.

### Примеры

- В паттерне Model-View-Controller, controller является посредником между view/use и model.

#### [Пример](code/main.py)

**Цель:** Создать простую модель чат-комнаты, где участники общаются друг с другом через посредника, что снижает
связанность между ними.

---

**Mediator** – абстрактный класс, определяющий методы ```register()``` и ```send_message()```.

```python
# Интерфейс медиатора
class Mediator(ABC):
    @abstractmethod
    def register(self, user: "User") -> None:
        pass

    @abstractmethod
    def send_message(self, message: str, sender: "User") -> None:
        pass
```

```python
# Конкретный медиатор - чат-комната
class ChatRoom(Mediator):
    def __init__(self) -> None:
        self.users = []

    def register(self, user: "User") -> None:
        if user not in self.users:
            self.users.append(user)
            user.set_mediator(self)
            print(f"{user.get_name()} присоединился к чат-комнате.")

    def send_message(self, message: str, sender: "User") -> None:
        for user in self.users:
            if user != sender:
                user.receive(message)
```

---

**User** – класс пользователя, который имеет имя и ссылку на медиатора. Методы ```send()``` и ```receive()``` выводят
сообщения, а ```send()``` также вызывает метод ```send_message()``` медиатора.

```python
# Класс пользователя
class User:
    def __init__(self, name: str) -> None:
        self.name = name
        self.mediator = None

    def set_mediator(self, mediator: Mediator) -> None:
        self.mediator = mediator

    def get_name(self) -> str:
        return self.name

    def send(self, message: str) -> None:
        print(f"{self.name} отправил сообщение: {message}")
        if self.mediator:
            self.mediator.send_message(message, self)

    def receive(self, message: str) -> None:
        print(f"{self.name} получил сообщение: {message}")
```

---

**main()** – демонстрирует создание чат-комнаты, регистрацию пользователей и обмен сообщениями.

```python
# Клиентский код
def main():
    chat_room = ChatRoom()

    alice = User("Alice")
    bob = User("Bob")
    charlie = User("Charlie")

    chat_room.register(alice)
    chat_room.register(bob)
    chat_room.register(charlie)

    alice.send("Привет всем!")
    bob.send("Привет, Alice!")
    charlie.send("Здравствуйте!")


if __name__ == "__main__":
    main()
```

## Плюсы данного паттерна

- Устраняет зависимости между компонентами, позволяя повторно их использовать.
- Упрощает взаимодействие между компонентами.
- Централизует управление в одном месте.

## Недостатки данного паттерна

- Посредник может сильно раздуться и легко превратиться в God-класс.

## Между **Mediator** и **Observer** по началу сложно уловить разницу.

### Если по-умному, то их различие в следующем:

Паттерн **Observer** уменьшает связанность за счёт обращения зависимостей. Он хорошо применим, когда есть несколько
источников событий и много слушателей, которые добавляются динамически. Другим хорошим примером использования этого
паттерна является реактивное программирование, когда изменение состояния одного объекта приводит к изменению состояния
всех зависимых от него объектов и так далее.

Паттерн **Mediator** уменьшает связанность системы за счёт того, что все зависимости уходят в один класс медиатор, а все
остальные классы становятся независимы и отвечают только за логику, которую они выполняют. Таким образом, добавление
новых классов становится проще, но с каждым новым классом логика медиатора сильно усложняется.

#### Если пытаться объяснить проще:

Паттерн **Observer** нужен когда мы хотим, чтобы на изменение одного объекта реагировало множество (даже если множество
состоит из 1ого) других объектов. При этом мы не хотим, что этот объект-издатель (на изменение состояния которого мы
реагируем) знал о подписчиках (объектах, которые реагируют на его изменение). *Связь одностроняя, подписичик знают об
издателе, но издатель не знает о подписчиках*

Паттерн **Mediator** позволяет вынести обоюдные связи множества объектов в отдельный класс. При этом все объекты будут
знать только о mediator'е, но не друг о друге. То есть в данном случае mediator можно представить в виде шины общения.
*Все знают о mediator'e, внутри него уже происходит связь, причем в основном двусторонняя*.

