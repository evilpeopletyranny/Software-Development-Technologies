# Command

## Команда

**Команда** — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как
аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

#### Основная идея

Паттерн "Команда" разделяет объект, инициирующий запрос, от объектов, которые его выполняют. Это достигается путем
создания отдельных объектов-команд, каждая из которых реализует определенное действие.

#### Применение

Паттерн "Команда" рекомендуется использовать в следующих случаях:

- **Необходимо параметризовать объекты с операциями:** Когда объекты должны быть настроены с разными действиями.
- **Требуется поддержка отмены и повторного выполнения операций:** Когда нужно иметь возможность отменить или повторить
  выполненные действия.
- **Необходимо организовать очередь запросов или логи действий:** Для управления запросами в очереди или записи действий
  для аудита.
- **Требуется разделить инициирующий объект и объект, выполняющий действие:** Для уменьшения связанности между
  компонентами системы.

### Реализация

1. Создайте общий интерфейс команд и определите в нём метод запуска.
2. Один за другим создайте классы конкретных команд. В каждом классе должно быть поле для хранения ссылки на один или
   несколько объектов-получателей, которым команда будет перенаправлять основную работу.

   Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. Значения
   всех этих полей команда должна получать через конструктор.

   И наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.
3. Добавьте в классы отправителей поля для хранения команд. Объект-отправитель должен принимать готовый объект команды
   извне через конструктор, либо через сеттер команды.
4. Измените основной код отправителей так, чтобы они делегировали выполнение действия команде.
5. Порядок инициализации объектов должен выглядеть так:
    - Создаём объекты получателей.
    - Создаём объекты команд, связав их с получателями.
    - Создаём объекты отправителей, связав их с командами.

### Примеры

#### [Пример](code%2Fexample2_new_texteditor%2FMain.java) с текстовым редактором

Создадим простой текстовый редактор, который позволяет выполнять операции вставки и удаления текста с
возможностью отмены и повтора этих операций.

_Дополнительно: в данном примере также присутствует паттерн **Снимок**._

---

Интерфейс ```Command``` - команда, определяет методы ```execute()``` и ```undo()```.

```python
# Интерфейс (абстрактный класс) команды
class Command(ABC):
    @abstractmethod
    def execute(self) -> None:
        pass

    @abstractmethod
    def undo(self) -> None:
        pass
```

---

Класс ```TextEditor``` - получатель. Класс над которым выполняются команды (получает команды).

```python
# Получатель: текстовый редактор
class TextEditor:
    def __init__(self) -> None:
        self.text = ""

    def insert(self, position: int, content: str) -> None:
        if position < 0 or position > len(self.text):
            raise ValueError("Invalid position")
        self.text = self.text[:position] + content + self.text[position:]
        print(f'Inserted "{content}" at position {position}')

    def delete(self, position: int, length: int) -> None:
        if position < 0 or position + length > len(self.text):
            raise ValueError("Invalid position or length")
        removed = self.text[position:position + length]
        self.text = self.text[:position] + self.text[position + length:]
        print(f'Deleted "{removed}" from position {position}')

    def get_text(self) -> str:
        return self.text
```

---

Конкретная команда - вставка - ```InsertCommand```.

```python
# Конкретная команда для вставки текста
class InsertCommand(Command):
    def __init__(self, editor: TextEditor, position: int, content: str) -> None:
        self.editor = editor
        self.position = position
        self.content = content

    def execute(self) -> None:
        self.editor.insert(self.position, self.content)

    def undo(self) -> None:
        self.editor.delete(self.position, len(self.content))
```

---

Конкретная команда - удаление - ```DeleteCommand```.

```python
# Конкретная команда для удаления текста
class DeleteCommand(Command):
    def __init__(self, editor: TextEditor, position: int, length: int) -> None:
        self.editor = editor
        self.position = position
        self.length = length
        self.removed_text = ""

    def execute(self) -> None:
        # Сохраняем удаляемый фрагмент для возможности отмены
        self.removed_text = self.editor.get_text()[self.position:self.position + self.length]
        self.editor.delete(self.position, self.length)

    def undo(self) -> None:
        self.editor.insert(self.position, self.removed_text)
```

---

История ```History``` - паттерн Снимок. Позволяет перемещаться по истории команд.

```python
# Класс для хранения истории команд (реализован как стек)
class History:
    def __init__(self) -> None:
        self._commands = []

    def push(self, cmd: Command) -> None:
        self._commands.append(cmd)

    def pop(self) -> Command:
        return self._commands.pop() if self._commands else None

    def is_empty(self) -> bool:
        return len(self._commands) == 0
```

---

```python
# Клиентский код (аналог Main.java)
def main():
    editor = Editor()

    # Вставка текста "Hello "
    insert_hello = InsertCommand(editor.text_editor, 0, "Hello ")
    editor.execute_command(insert_hello)
    editor.print_text()  # Ожидается: "Hello "

    # Вставка текста "World!" в конец текущего текста
    insert_world = InsertCommand(editor.text_editor, len(editor.text_editor.get_text()), "World!")
    editor.execute_command(insert_world)
    editor.print_text()  # Ожидается: "Hello World!"

    # Удаление "World!" начиная с позиции 6, длиной 6 символов
    delete_world = DeleteCommand(editor.text_editor, 6, 6)
    editor.execute_command(delete_world)
    editor.print_text()  # Ожидается: "Hello "

    # Отмена последнего действия (восстановление "World!")
    editor.undo()
    editor.print_text()  # Ожидается: "Hello World!"

    # Отмена вставки "World!"
    editor.undo()
    editor.print_text()  # Ожидается: "Hello "

    # Отмена вставки "Hello "
    editor.undo()
    editor.print_text()  # Ожидается: ""

    # Попытка отменить еще одну команду
    editor.undo()  # Выведет сообщение, что команд для отмены нет


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Снижение связанности:** Отправитель запроса (```Invoker```) не зависит от получателя (```Receiver```) и конкретных
  команд. Это облегчает изменение и расширение системы.
- **Гибкость и расширяемость:** Легко добавлять новые команды без изменения существующих классов.
- **Поддержка отмены операций:** Возможность реализации методов ```undo()``` для отмены выполненных команд.
- **Организация запросов:** Позволяет хранить, передавать и управлять запросами как объектами.
- **Реализация макрокоманд:** Возможность объединения нескольких команд в одну.

### Недостатки данного паттерна

- **Увеличение числа классов:** Каждая новая команда требует создания нового класса, что может привести к увеличению
  сложности проекта.
- **Сложность отладки:** Из-за большого количества классов может быть сложнее отслеживать и понимать поток выполнения
  программы.
- **Небольшие преимущества для простых систем:** В простых приложениях использование паттерна может быть избыточным и
  усложнять код.

### Заключение

Паттерн Команда (Command) является мощным инструментом для инкапсуляции запросов как объектов, что обеспечивает
гибкость, расширяемость и упрощает управление действиями в системе. Он широко применяется в различных областях, таких
как системы управления устройствами, GUI-приложения, системы логирования и многие другие.

Паттерн "Команда" широко используется в графических интерфейсах (например, обработка событий кнопок), системах
управления устройствами (умный дом), системах логирования, системах транзакций и многих других областях, где требуется
гибкое управление действиями и их отмена.

Однако, при использовании паттерна "Команда" важно учитывать его преимущества и недостатки, чтобы не создавать
избыточную структуру классов в простых системах.
