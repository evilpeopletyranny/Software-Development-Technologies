# Facade

## Фасад

**Фасад** — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов,
библиотеке или фреймворку.

В разработке программного обеспечения часто возникает необходимость взаимодействовать с комплексными системами или
наборами классов, которые имеют сложные интерфейсы. Это может усложнить процесс интеграции и повысить связанность между
компонентами системы. Паттерн проектирования **Фасад** (Facade) предоставляет решение этой проблемы, предлагая простой
интерфейс для взаимодействия с более сложными системами или библиотеками.

Один из самых простых паттернов. Скорее всего вы его часто используете, даже не задумываясь, что это фасад.

#### Основная идея

Основная идея паттерна Фасад заключается в том, чтобы предоставить клиентам простой интерфейс для взаимодействия с
комплексной подсистемой, делегируя вызовы соответствующим объектам внутри подсистемы. Это снижает связанность между
клиентом и подсистемой, облегчает использование и понимание системы.

#### Применение

Примеры, когда можно использовать паттерн фасад:

1. Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
2. Когда вы хотите разложить подсистему на отдельные слои.
3. Когда необходимо скрыть особенности реализации от пользователя.

### Реализация

1. Определите можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема. Вы на
   правильном пути, если этот интерфейс избавит клиента от знания о подробностях подсистемы.
2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам
   подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.
3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае, изменения в подсистеме будут
   затрагивать только код фасада, а клиентский код останется рабочим.
4. Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов.

#### Типы Фасадов

- **Фасад для подсистемы:** Обеспечивает простой интерфейс для взаимодействия с одной подсистемой.
- **Фасад для архитектуры:** Может охватывать несколько подсистем, предоставляя единый интерфейс для различных
  компонентов системы.

### Примеры

#### [Пример](code/main.py) с работой двигателя автомобиля

Допустим у нас реализована правильная логика запуска двигателя автомобиля включающее множество шагов: включение
инжектора, ввод топлива, контроль этого всего и тд и тп. Но пользователю (автомобилисту) нет необходимости знать о том
как что происходит и в каком порядке. Он просто хочется сесть, завести машину и поехать.

Реализуем фасад, который внутри себя скрывает все процессы по запуску и останову двигателя автомобиля, а во внешний мир
для пользователя дадим лишь кнопку вкл/выкл.

Тем более прописав один раз правильный порядок выполнения действий и спрятав его пользователь не должен будет каждый раз
вспомним ать и реализовывать правильный порядок.

##### Классы для имитации двигателя автомобиля

```python
class TemperatureSensor:
    def get_temperature(self):
        print("Temperature Sensor get temperature")


class Starter:
    def start(self):
        print("Start!!!")


class Radiator:
    def on(self):
        print("Radiator on.")

    def off(self):
        print("Radiator off.")

    def set_speed(self):
        print("Radiator set speed.")


class FuelPump:
    def pump(self):
        print("FuelPump pump")


class FuelInjector:
    def __init__(self):
        self.fuel_pump = FuelPump()

    def on(self):
        print("Fuel Injector on.")

    def off(self):
        print("Fuel Injector off.")

    def inject(self):
        print("Fuel Injector inject")
        self.fuel_pump.pump()


class CoolingController:
    def __init__(self):
        self.radiator = Radiator()
        self.temperature_sensor = TemperatureSensor()

    def set_temperature_upper_limit(self, temp):
        print(f"Cooling Controller set temperature upper limit {temp}")
        self.temperature_sensor.get_temperature()

    def run(self):
        print("Cooling Controller run.")
        self.radiator.on()

    def cool(self, cool):
        print(f"Cooling Controller cool{cool}")

    def stop(self):
        print("Cooling Controller stop.")


class CatalyticConverter:
    def on(self):
        print("CatalyticConverter on")

    def off(self):
        print("CatalyticConverter off")


class AirFlowMeter:
    def get_measurement(self):
        print("AirFlowMeter get measurement")


class AirFlowController:
    def __init__(self):
        self.air_flow_meter = AirFlowMeter()

    def take_air(self):
        print("AirFlowController take air.")
        self.air_flow_meter.get_measurement()

    def off(self):
        print("AirFlowController off.")

```

##### Классы для тестирования

```python
from engine_facad import *


def main():
    DEFAULT_COOLING_TEMP = 90
    MAX_ALLOWED_TEMP = 50

    # Управление двигателем "вручную"
    print("Manual engine operations:")
    # Создаем компоненты двигателя
    fuel_injector = FuelInjector()
    air_flow_controller = AirFlowController()
    starter = Starter()
    cooling_controller = CoolingController()
    catalytic_converter = CatalyticConverter()

    # Правильная последовательность действий для включения двигателя
    air_flow_controller.take_air()
    fuel_injector.on()
    fuel_injector.inject()
    starter.start()
    cooling_controller.set_temperature_upper_limit(DEFAULT_COOLING_TEMP)
    cooling_controller.run()
    catalytic_converter.on()

    print("\n-------------------------\n")

    # Правильная последовательность действий для выключения двигателя
    fuel_injector.off()
    catalytic_converter.off()
    cooling_controller.cool(MAX_ALLOWED_TEMP)
    cooling_controller.stop()
    air_flow_controller.off()

    print("\n-------------------------\n")

    # Использование паттерна Фасад для управления двигателем
    print("Using CarEngineFacade:")
    engine_facade = CarEngineFacade()

    print("Starting engine via facade:")
    engine_facade.start_engine()

    print("\nStopping engine via facade:")
    engine_facade.stop_engine()


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Упрощение интерфейса:** Клиенты взаимодействуют с подсистемой через простой интерфейс, не зная о её внутренней
  сложности.
- **Снижение связанности:** Фасад изолирует клиентов от деталей реализации подсистемы, что облегчает изменение
  подсистемы без влияния на клиентский код.
- **Упрощение использования:** Позволяет клиентам выполнять сложные операции через несколько простых методов фасада.
- **Повышение модульности:** Разделение ответственности между фасадом и подсистемой улучшает структуру кода и облегчает
  его поддержку.

### Недостатки данного паттерна

- **Ограничение гибкости:** Клиентский код может быть ограничен предоставляемыми фасадом возможностями и не иметь
  доступа к более тонким аспектам подсистемы.
- **Добавление дополнительного уровня абстракции:** Может увеличить количество классов в системе, что усложняет её
  структуру.
- **Необходимость поддерживать фасад:** При изменении подсистемы может потребоваться обновление фасада, чтобы он
  соответствовал новым возможностям или интерфейсам.

### Заключение

Паттерн проектирования **Фасад** является мощным инструментом для упрощения взаимодействия с комплексными системами и
подсистемами. Он предоставляет клиентам единый, упрощённый интерфейс, скрывая внутреннюю сложность и снижая связанность
между компонентами системы.

Правильное применение паттерна Фасад способствует созданию более чистой, модульной и легко поддерживаемой архитектуры
приложений. Однако, как и любой паттерн, его следует применять осознанно, учитывая требования и специфику проекта, чтобы
избежать избыточной абстракции и усложнения системы.
