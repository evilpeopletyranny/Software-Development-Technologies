# Iterator

## Итератор

**Итератор** — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы
составных объектов, не раскрывая их внутреннего представления.

#### Основная идея

Паттерн Итератор отделяет алгоритм перебора элементов коллекции от самой коллекции, позволяя использовать один и тот же
алгоритм для различных коллекций. Это упрощает работу с коллекциями и повышает их гибкость.

## Применимость

- Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или
  вопросов безопасности).
- Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
- Когда вам хочется иметь единый интерфейс обхода различных структур данных.

## Реализация

В Python концепция итерации встроена в язык. Любой объект, который реализует метод ```__iter__()``` (
или ```__getitem__()``` с индексами от 0 до конца), считается итерируемым. При вызове функции ```iter(obj)``` Python
возвращает объект-итератор, который должен реализовывать метод ```__next__()``` для получения следующего элемента (или
возбуждать исключение ```StopIteration```, когда элементы закончились).

## Примеры

### Использование метода ```__getitem__```

Если класс реализует метод ```__getitem__```, то Python автоматически делает его итерируемым. При итерации Python
вызывает этот метод начиная с индекса 0 до тех пор, пока не будет возбуждено исключение ```IndexError```.

```python
class MySequence:
    def __init__(self, data):
        self.data = data

    def __getitem__(self, index):
        # Если индекс валиден, возвращаем элемент, иначе возбуждаем IndexError
        if index < len(self.data):
            return self.data[index]
        else:
            raise IndexError("Index out of range")


def main():
    seq = MySequence([10, 20, 30, 40, 50])
    print("Итерация через __getitem__:")
    for item in seq:
        print(item)


if __name__ == '__main__':
    main()

```

### Метод ```__iter__``` реализуемый внутри класса

Можно определить итератор, реализовав метод ```__iter__()``` (и/или создать отдельный класс итератора с
методом ```__next__()```). Вот два варианта:

```python
class MySequence:
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        # Использование генератора для последовательного возврата элементов
        for item in self.data:
            yield item


def main():
    seq = MySequence([100, 200, 300, 400, 500])
    print("\nИтерация через __iter__ с генератором:")
    for item in seq:
        print(item)


if __name__ == '__main__':
    main()

```

### Метод ```__iter__``` с отдельным классом итератора

```python
class MySequenceIterator:
    def __init__(self, data):
        self._data = data
        self._index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self._index < len(self._data):
            result = self._data[self._index]
            self._index += 1
            return result
        raise StopIteration


class MySequence:
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        return MySequenceIterator(self.data)


def main():
    seq = MySequence(['a', 'b', 'c', 'd'])
    print("\nИтерация через отдельный итератор:")
    for item in seq:
        print(item)


if __name__ == '__main__':
    main()

```

### Итератор для неиндексируемых коллекций

Паттерн итератор также может быть реализован для неиндексированных коллекций, перебирая элементы в случайном порядке, но
необходимо обеспечить перебор всех элементов.

Если паттерн реализуется для структуры, которая внутри представляет собой "связный" список, то в таком случает можно
двигаться не через счетчик в явном виде, а по указателям "узлов", пока не будет достигнут такой узел, у которого нет
следующего элемента.

## Плюсы данного паттерна

- Упрощает классы хранения данных.
- Позволяет реализовать различные способы обхода структуры данных
- Позволяет одновременно перемещаться по структуре данных в разные стороны.

## Недостатки данного паттерна

- **Хороший паттерн, нет минусов**
- **Дополнительные накладные расходы:** Создание и использование итераторов требует дополнительной памяти и времени.
- **Необходимость синхронизации при одновременном доступе:** В многопоточных приложениях может потребоваться
  синхронизация доступа к коллекциям при использовании итераторов.
- **Ограниченная функциональность:** Итераторы обычно предоставляют только последовательный доступ к элементам, что
  может быть недостаточно для некоторых задач.
- **Необходимость правильного использования методов ```hasNext()``` и ```next()```:** Ошибки в логике перебора могут
  привести к пропуску элементов или выбросу исключений.

### Заключение

Паттерн Итератор (Iterator) является фундаментальным поведенческим паттерном, который предоставляет стандартный способ
перебора элементов коллекций без раскрытия их внутренней структуры. Он способствует снижению связанности между
клиентским кодом и коллекциями, обеспечивая гибкость и расширяемость системы.

Однако, при использовании паттерна Итератор важно учитывать его преимущества и недостатки, особенно в контексте
производительности и синхронизации в многопоточных приложениях.
