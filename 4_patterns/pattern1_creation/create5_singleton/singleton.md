# Singleton

## Одиночка

**Одиночка** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и
предоставляет к нему глобальную точку доступа.

1. Синглтон гарантирует наличие единственного экземпляра класса.
   Чаще всего это полезно для доступа к какому-то общему
   ресурсу, например, базе данных.
2. Предоставляет глобальную точку доступа. Это не просто
   глобальная переменная, через которую можно достучаться
   к определённому объекту. Глобальные переменные не
   защищены от записи, поэтому любой код может подменять
   их значения без вашего ведома.

#### Основная идея

Основная идея паттерна Синглтон заключается в том, чтобы контролировать создание экземпляра класса, гарантируя, что он
существует в единственном числе, и обеспечивать доступ к нему из любой части программы.

#### Применение

Паттерн Синглтон рекомендуется использовать в следующих случаях:

- **Необходимость наличия одного и только одного экземпляра класса**: Например, класс, управляющий подключением к базе
  данных, логированием, конфигурациями приложения.
- **Предоставление глобальной точки доступа**: Когда необходимо обеспечить доступ к одному экземпляру класса из разных
  частей программы.
- **Контроль над доступом к ресурсам**: Например, управление пулом соединений, потоками и т.д.

### Примеры

#### [Синглтон через модуль](code/module_singleton/singleton.py)

Так как модули в Python загружаются только один раз и кэшируются, сам по себе модуль ведёт себя как синглтон.

```Python
class MySingleton:
    def some_method(self):
        print("Hello from singleton!")


# Создавать экземпляры не нужно – можно импортировать класс или даже готовый объект:
singleton = MySingleton()
```

- Самый простой способ, полагающийся на то, что модуль загружается один раз.

#### [Реализация](code/new/singleton.py) с использованием переопределения __new__

Переопределяя метод ```__new__```, можно контролировать создание экземпляра. Для потокобезопасности используется
блокировка.

```python
import threading


class SingletonNew:
    _instance = None
    _lock = threading.Lock()  # Потокобезопасная блокировка

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:  # Вторичная проверка
                    cls._instance = super().__new__(cls)
        return cls._instance

    def some_method(self):
        print("Hello from SingletonNew!")


if __name__ == "__main__":
    s1 = SingletonNew()
    s2 = SingletonNew()
    print(s1 is s2)  # True
    print(s1.some_method())

```

- Позволяет управлять созданием экземпляров на уровне класса; можно добавить потокобезопасность.

#### [Реализация](code/metaclass/singleton.py) с использованием метакласса

Реализация с использованием синхронизированного метода, который обеспечивает потокобезопасность.

```python
import threading
from abc import ABCMeta


class SingletonMeta(type):
    _instances = {}
    _lock = threading.Lock()  # Потокобезопасная блокировка для доступа к _instances

    def __call__(cls, *args, **kwargs):
        with cls._lock:
            if cls not in cls._instances:
                instance = super().__call__(*args, **kwargs)
                cls._instances[cls] = instance
        return cls._instances[cls]


class MySingleton(metaclass=SingletonMeta):
    def some_method(self):
        print("Hello from MySingleton (metaclass)!")


if __name__ == "__main__":
    s1 = MySingleton()
    s2 = MySingleton()
    print(s1 is s2)  # True

```

- Универсальный способ для всех классов, использующих данный метакласс.

#### Реализация через декоратор

Можно написать декоратор, который будет оборачивать класс и гарантировать, что создаётся лишь один экземпляр.
Потокобезопасная версия также использует блокировку.

```python
import threading

def singleton(cls):
    instances = {}
    lock = threading.Lock()

    def getinstance(*args, **kwargs):
        with lock:
            if cls not in instances:
                instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return getinstance

@singleton
class MyDecoratedSingleton:
    def some_method(self):
        print("Hello from MyDecoratedSingleton!")

if __name__ == "__main__":
    s1 = MyDecoratedSingleton()
    s2 = MyDecoratedSingleton()
    print(s1 is s2)  # True
```

### Почему singleton антипаттерн?

![mem.png](img/mem.png)

Несмотря на свою популярность, паттерн Синглтон часто критикуется и рассматривается как антипаттерн по ряду причин:

1. **Глобальное состояние**. Синглтон предоставляет глобальную точку доступа к экземпляру, что фактически создает
   глобальное состояние. Глобальные переменные известны своими проблемами, такими как:
    - Скрытые зависимости: Классы, использующие Синглтон, зависят от него неявно, что затрудняет понимание зависимостей
      и ведение кода.
    - Трудности в тестировании: Глобальные состояния усложняют написание юнит-тестов, так как состояние Синглтона может
      влиять на другие тесты.
2. **Усложнение модульности и расширяемости**. Синглтон может затруднить расширение и модификацию системы, поскольку все
   части программы, использующие Синглтон, напрямую зависят от его конкретной реализации.
3. **Нарушение принципа единственной ответственности (Single Responsibility Principle)**. Синглтон отвечает за создание
   объекта, управление доступа к нему. Также сама суть синглтона накладывает ограничения на поведение.
4. **Проблемы с наследованием**. Синглтон затрудняет наследование, так как создание экземпляров контролируется самим
   классом.
5. **Необходимость синхронизации**. Некоторые реализации Синглтона требуют синхронизации, что может негативно сказаться
   на производительности и привести к ошибкам в многопоточной среде.
6. **Уязвимость к рефлексии и сериализации**. Некоторые реализации Синглтона могут быть нарушены с помощью рефлексии или
   сериализации, что позволяет создавать дополнительные экземпляры.
7. **Проблемы с управлением жизненным циклом**. Синглтон живёт на протяжении всей жизни приложения, что может привести к
   утечкам памяти, если он хранит ссылки на объекты, которые уже не нужны.
8. **Нарушение принципов SOLID**
    - **Принцип открытости/закрытости (Open/Closed Principle)**: Синглтон может требовать изменения кода при добавлении
      новых функциональностей.
    - **Принцип инверсии зависимостей (Dependency Inversion Principle)**: Синглтон вводит жёсткую зависимость от
      конкретной реализации, что усложняет внедрение зависимостей.
