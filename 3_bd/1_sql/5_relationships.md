# Связи (отношения) между таблицами

## 1 к 1

Самый редкий связи, но при этом самый интересный. Использование связи 1 к 1 является оправданным в следующих случаях:

- Для логического выделения двух отдельных сущностей, но которые действительно могут иметь только связь 1 к 1
- Для "разбиения" данных "условно одной таблицы" на несколько. Например, на часто используемые данные и полные данные,
  но используемые намного реже.
    - Пример: в соц. сетях почти всегда и везде используется ваш username/фамилия+имя для чатов, групп и тд и тп. Но у
      каждого аккаунта пользователя кроме этих данных также есть более полное БИО (если оно заполнено): год рождения,
      любимые книги, политические взгляды и тд и тп.

Связь 1 к 1 может быть реализована несколькими способами.

### Вариант 1: Таблица с внешним ключом и уникальным ограничением

Создадим две таблицы, где в одной таблице (например, ```user_profiles```) внешний ключ ссылается на первичный ключ
другой таблицы (```users```) и при этом имеет ограничение ```UNIQUE```:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);

CREATE TABLE user_profiles (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL UNIQUE,
    bio TEXT,
    CONSTRAINT fk_user
      FOREIGN KEY(user_id) 
        REFERENCES users(id)
);
```

- В таблице ```user_profiles``` столбец ```user_id``` обязательно должен быть уникальным — это гарантирует, что каждому
  пользователю из таблицы ```users``` соответствует не более одной записи профиля.
- При таком подходе каждая запись в ```users``` может иметь либо одну, либо ни одной записи в user_profiles, что и
  соответствует связи "один к одному".

### Вариант 2: Использование общего первичного ключа

Можно также реализовать связь "один к одному", если таблица зависимостей использует в качестве первичного ключа значение
из родительской таблицы

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);

CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,  -- также является внешним ключом
    bio TEXT,
    CONSTRAINT fk_user
      FOREIGN KEY(user_id)
        REFERENCES users(id)
);
```

- В таблице ```user_profiles``` столбец ```user_id``` является одновременно первичным ключом и внешним ключом, что
  гарантирует, что каждая запись профиля соответствует ровно одному пользователю, а пользователь может иметь не более
  одного профиля.

## 1 к n

В реляционных базах данных связь "один к многим" (1 к N) реализуется посредством внешнего ключа. Это означает, что в
таблице, которая находится со стороны "многих" (N), добавляется столбец, ссылающийся на первичный ключ таблицы,
находящейся со стороны "одного" (1). Такой подход гарантирует, что каждая запись в таблице "многих" связана ровно с
одной записью в таблице "одного", а одна запись в таблице "одного" может соответствовать нескольким записям в таблице "
многих".

Предположим, у нас есть таблица пользователей и таблица заказов, где один пользователь может иметь несколько заказов.

```sql
-- Таблица пользователей
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);

-- Таблица заказов, где поле user_id является внешним ключом,
-- ссылающимся на users.id.
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    order_date TIMESTAMP,
    amount NUMERIC(10,2),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

- Таблица ```users``` имеет столбец ```id``` как первичный ключ, который однозначно идентифицирует каждого пользователя.
- Таблица ```orders``` содержит столбец ```user_id```, который указывает, какому пользователю принадлежит заказ. Это
  поле объявлено как внешний ключ, ссылающийся на users(id), что обеспечивает целостность данных — заказ не может быть
  создан без соответствующего пользователя.

Таким образом, связь "один к многим" реализуется через внешний ключ в таблице "многих". Это стандартный способ
моделирования отношений один ко многим реляционных СУБД.

## n к n

Связь "многие ко многим" (n к n) в реляционных СУБД реализуется посредством создания дополнительной **таблицы-связи**,
которая содержит внешние ключи, ссылающиеся на первичные ключи двух таблиц, участвующих в отношении. Такая таблица
позволяет связать одну запись из первой таблицы с несколькими записями из второй таблицы и наоборот.

Предположим, у нас есть две таблицы: ```students``` и ```courses```, и один студент может записаться на несколько
курсов, а один курс — иметь нескольких студентов.

```sql
-- Таблица студентов
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- Таблица курсов
CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL
);

-- Таблица-связка для реализации отношения "многие ко многим"
CREATE TABLE student_course (
    student_id INTEGER NOT NULL,
    course_id INTEGER NOT NULL,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(id),
    FOREIGN KEY (course_id) REFERENCES courses(id)
);
```

- Таблицы ```students``` и ```courses```: Каждая из них имеет свой первичный ключ (столбец ```id```).
- Таблица-связка ```student_course```:
    - Содержит два столбца: ```student_id``` и ```course_id```, которые являются внешними ключами, ссылающимися
      на ```students.id``` и ```courses.id``` соответственно.
    - Совместный первичный ключ (```student_id```, ```course_id```) гарантирует, что каждая пара значений уникальна и
      предотвращает дублирование связей.

Таким образом, для реализации отношения "многие ко многим" создается дополнительная таблица-связка, которая связывает
записи из двух таблиц посредством внешних ключей. Это стандартный способ моделирования подобных отношений в реляционных
базах данных.