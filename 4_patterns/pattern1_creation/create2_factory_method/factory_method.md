# Factory Method

## Фабричный метод

**Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в
суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого
фабричного метода.

На первый взгляд, это может показаться бессмысленным — мы просто переместили вызов из одного конца программы в другой.
Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта. Чтобы эта
система работала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных
классов, следующих одному и тому же интерфейсу

#### Основная идея

Основная цель паттерна Фабричный метод — **делегировать создание объектов подклассам**, позволяя тем самым изменять тип
создаваемых объектов без изменения кода, который использует эти объекты.

#### Применение

Паттерн Фабричный метод рекомендуется использовать в следующих случаях:

- Когда необходимо определить интерфейс для создания объектов, но оставить выбор конкретных классов подклассам.
- Когда класс не должен знать о конкретных классах создаваемых объектов.
- Когда необходимо обеспечить возможность расширения системы новыми типами объектов без изменения существующего кода.
- Когда процесс создания объекта сложен и включает в себя множество шагов или параметров.

### Реализация

1. Создание общего интерфейса объектов, которые будет создавать производитель и его подкласс.
2. Реализация конкретных продуктов, которую реализуют общей интерфейс.
3. Создание создателя.
4. Создатель объявляет фабричный метод, создающий объекты через общий интерфейс продуктов.
5. Создание конкретных создателей, каждый из которых по своему реализует фабричный метод, производящий те или иные
   продукты.

### Примеры

#### Пример [Transport](code%2Fexample2_transport%2FTransportMain.java)

Создадим систему, которая может создавать различные транспортные средства, такие как автомобили и велосипеды. Используя
паттерн Фабричный метод, мы обеспечим гибкость при добавлении новых типов транспортных средств без изменения
существующего кода.

##### Общий интерфейс ```Transport```:

```python
from abc import ABC, abstractmethod

# Общий интерфейс "продукта" - транспорт
class Transport(ABC):
    @abstractmethod
    def drive(self):
        pass
```

##### Конкретные продукты: ```Car``` и ```Bike```:

```python
# Конкретный продукт - Car
class Car(Transport):
    def drive(self):
        print("Вождение автомобиля.")
```

```python
# Конкретный продукт - Bike
class Bike(Transport):
    def drive(self):
        print("Вождение велосипеда.")
```

##### Абстрактный создатель ```TransportFactory```:

В общем для абстрактного создателя можно определить как и **абстрактный класс** так и **интерфейс**. Зависит от
ситуации.

```python
from abc import ABC, abstractmethod

# Абстрактный создатель (фабрика)
class TransportFactory(ABC):
    @abstractmethod
    def create_transport(self) -> Transport:
        pass
```

##### Конкретные создатели: ```CarFactory``` и ```BikeFactory```:

```python
# Конкретный создатель для Car
class CarFactory(TransportFactory):
    def create_transport(self) -> Transport:
        return Car()
```

```python
# Конкретный создатель для Bike
class BikeFactory(TransportFactory):
    def create_transport(self) -> Transport:
        return Bike()
```

##### Класс для тестирования:

Обратите внимание как меняются фабрики по ходу исполнения программы. Одна, наверное, одна из главных причин
использования фабрики - по ходу исполнения в зависимости от выбора мы можем изменять фабрику, при этом методы работы с
ней не изменяются.

```python
def main():
    # Создаем фабрику для автомобиля и создаем объект Car
    factory: TransportFactory = CarFactory()
    car = factory.create_transport()

    # Смена фабрики: создаем фабрику для велосипеда и создаем объект Bike
    factory = BikeFactory()
    bike = factory.create_transport()

    car.drive()
    bike.drive()

if __name__ == '__main__':
    main()
```

### Плюсы данного паттерна

- **Гибкость и расширяемость**: Позволяет легко добавлять новые типы продуктов без изменения существующего кода.
- **Снижение связанности**: Клиенты не зависят от конкретных классов продуктов, а работают с абстракциями (Interface или
  Abstract Class).
- **Упрощение кода**: Избавляет от необходимости использовать длинные условные операторы для создания объектов различных
  типов.
- **Соблюдение принципов SOLID**:
    - **Принцип единственной ответственности (Single Responsibility Principle)**: Отделяет процесс создания объектов от
      их использования.
    - **Принцип открытости/закрытости (Open/Closed Principle)**: Классы открыты для расширения, но закрыты для
      модификации.

### Недостатки данного паттерна

- **Увеличение количества классов**: Для каждого типа продукта требуется создать отдельный класс-фабрику, что может
  привести к увеличению числа классов в проекте.
- **Сложность понимания**: Для новичков паттерн может показаться сложным из-за использования абстрактных классов и
  интерфейсов.
