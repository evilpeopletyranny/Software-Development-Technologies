# Visitor

## Посетитель

**Посетитель** — это поведенческий паттерн проектирования, который позволяет создавать новые операции, не меняя классы
объектов, над которыми эти операции могут выполняться.

*Паттерн хороший, но имеет неприятный краевой случай про который буде описано далее.*

#### Основная идея

Паттерн Посетитель позволяет определить новую операцию без изменения классов объектов, над которыми эта операция будет
выполняться. Это достигается путем добавления метода accept в иерархию объектов, который принимает посетителя и вызывает
соответствующий метод у него.

#### Применение

- Когда вам нужно выполнить операцию над всеми элементами сложной структуры объектов (например, деревом).
- Когда над объектами сложной структуры объектов надо выполнять некоторые, не связанные между собой операций, но вы не
  хотите «засорять» классы такими операциями.
- Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

### Реализация

1. Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса компонента, который необходимо
   посетить.
2. Опишите интерфейс компонентов. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия
   посетителей в базовом классе иерархии компонентов.
3. Если есть возможность: Реализуйте методы принятия во всех конкретных компонентах. Они должны переадресовывать вызовы
   тому методу посетителя, в котором класс параметра совпадает с текущим классом компонента - метод двойной
   диспетчеризации.
4. Иерархия компонентов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать
   обо всех классах компонентов.
5. Для каждого нового поведения создайте свой конкретный класс. Приспособьте это поведение для всех посещаемых
   компонентов, реализовав все методы интерфейса посетителей.
6. Клиент будет создавать объекты посетителей, а затем передавать их компонентам, используя метод принятия.

#### [main.py](code/main.py) с обходом фигур

**Цель:** Создать структуру, содержащую различные геометрические фигуры (```Circle```, ```Rectangle```), и реализовать
посетителя, который выполняет операцию печати информации о каждой фигуре.

--- 

```Element``` и ```Visitor```: Абстрактные классы определяют контракт для элементов и посетителей.

```python
# Интерфейс элемента (Element)
class Element(ABC):
    @abstractmethod
    def accept(self, visitor: "Visitor") -> None:
        pass
```

```python
# Интерфейс посетителя (Visitor)
class Visitor(ABC):
    @abstractmethod
    def visit_circle(self, circle: "Circle") -> None:
        pass

    @abstractmethod
    def visit_rectangle(self, rectangle: "Rectangle") -> None:
        pass

```

---

```Circle``` и ```Rectangle```: Реализуют метод ```accept()```, который вызывает соответствующий метод посетителя.

```python
# Конкретный элемент - Circle
class Circle(Element):
    def __init__(self, radius: float) -> None:
        self.radius = radius

    def get_radius(self) -> float:
        return self.radius

    def accept(self, visitor: Visitor) -> None:
        visitor.visit_circle(self)


# Конкретный элемент - Rectangle
class Rectangle(Element):
    def __init__(self, width: float, height: float) -> None:
        self.width = width
        self.height = height

    def get_width(self) -> float:
        return self.width

    def get_height(self) -> float:
        return self.height

    def accept(self, visitor: Visitor) -> None:
        visitor.visit_rectangle(self)
```

---

```PrintVisitor```: Реализует методы ```visit_circle()``` и ```visit_rectangle()```, выводящие информацию о фигуре.

```python
# Конкретный посетитель - PrintVisitor
class PrintVisitor(Visitor):
    def visit_circle(self, circle: Circle) -> None:
        print(f"Circle with radius: {circle.get_radius()}")

    def visit_rectangle(self, rectangle: Rectangle) -> None:
        print(f"Rectangle with width: {rectangle.get_width()} and height: {rectangle.get_height()}")
```

---

```main()```: Создаёт список фигур и для каждой вызывает метод ```accept()```, передавая экземпляр ```PrintVisitor```.

```python
# Клиентский код (аналог Main.java)
def main():
    shapes = [
        Circle(5.0),
        Rectangle(4.0, 6.0),
        Circle(3.5),
        Rectangle(2.0, 3.0)
    ]

    printer = PrintVisitor()

    for shape in shapes:
        shape.accept(printer)

if __name__ == "__main__":
    main()
```

---

### Плюсы данного паттерна

- Упрощает добавление новых операций над всей связанной структурой объектов.
- Объединяет родственные операции в одном классе.
- Посетитель может накоплять состояние при обходе структуры компонентов.

### Недостатки данного паттерна

- Паттерн неоправдан, если иерархия компонентов часто меняется.
- Может привести к нарушению инкапсуляции компонентов.
- Сложная реализация если классы компонентов не доступны для изменения.

### Сравнение с другими паттернами

Конечно паттерн **Посетитель** с первого взгляда может быть поход на **Итератор** - и там и там мы обходим элементы, но
на самом деле они имеют принципиальные отличия:

**Итератор** задает порядок обхода элемента и предоставляет клиентскому коду возможность воспользоваться этим
обходом - ```иетратором```.

**Посетитель** никак не связан с порядком обхода. Суть посетителя это выполнение действий с/над данными элементам.

Паттерны хорошо синергируют, когда при помощи **Итератора** мы задаем порядок обхода. Используя **Итератор** для обхода
**Посетитель** выполняет действия над данными.

### Заключение

**Паттерн Посетитель (Visitor)** предоставляет мощный способ разделения алгоритмов и объектов, над которыми они
выполняются. Он особенно полезен при работе со сложными структурами объектов, позволяя легко добавлять новые операции
без изменения их классов. Однако, как и любой паттерн, он имеет свои преимущества и недостатки, и его применение должно
быть обосновано конкретными требованиями проекта.
