# Adapter

## Адаптер

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать
вместе.

В разработке программного обеспечения часто возникает необходимость интегрировать различные компоненты и системы,
которые изначально не предназначены для совместной работы. Паттерн проектирования **Адаптер** (Adapter) предоставляет
способ сделать это, преобразуя интерфейс одного класса в интерфейс, ожидаемый клиентом. Это позволяет классам с
несовместимыми интерфейсами работать вместе без изменения их исходного кода.

#### Основная идея

Основная идея паттерна Адаптер заключается в том, чтобы предоставить промежуточный слой между двумя несовместимыми
интерфейсами, позволяющий им взаимодействовать без изменения их исходного кода.

#### Применение

Паттерн Адаптер рекомендуется использовать в следующих случаях:

- Необходимо использовать существующий класс, но его интерфейс несовместим с текущей системой.
- Разработка новых классов, совместимых с существующей системой.
- Интеграция библиотек или систем, имеющих разные интерфейсы.
- Превращение интерфейса одного класса в другой, ожидаемый клиентом.

### Реализация

1. Убедитесь, что у вас есть два класса с неудобными интерфейсами:
    - *полезный сервис* — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой
      код);
    - *один или несколько клиентов* — классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего
      интерфейса.
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать сторонний класс.
3. Создайте класс адаптера, реализовав этот интерфейс.
4. Поместите в адаптер поле-ссылку на объект-сервис. В большинстве случаев, это поле заполняется объектом, переданным в
   конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису
6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять
   адаптеры в будущем.

#### Вариации

Адаптер можно реализовать двумя способами:

- Основанном на классах. При этом используется наследование.
- Основанном на объектах. При этом используется композиция.

Оба подхода описаны в предлагаемых книгах.

В данном случае мы будем рассматривать подход основанный на композиции. Данный подход предпочтительней, так как:

- Наследование создает жесткую связь с классом родителя.
- Изменение класса родителя может влиять на адаптер.
- Класс не всегда можно унаследовать.
- Композиция позволяет добиться большей гибкости.

### Пример

#### Целевой интерфейс

```python
from abc import ABC, abstractmethod


class Target(ABC):
    """
    Целевой интерфейс, который необходимо реализовать
    """

    @abstractmethod
    def request(self) -> str:
        return "Target: The default target's behavior."
```

#### Одна из уже существующих реализаций интерфейса

```python
class ConcreteTarget(Target):
    """
    Одна из конкретных реализаций необходимого интерфейса
    """

    def request(self) -> str:
        return "Target: The default target's behavior."
```

#### Нечто не подходящее под нащ интерфейс

```python
class Adaptee:
    """
    Адаптируемый класс содержит некоторое полезное поведение, но его интерфейс
    несовместим с существующим клиентским кодом. Адаптируемый класс нуждается в
    некоторой доработке, прежде чем клиентский код сможет его использовать.
    """

    def specific_request(self) -> str:
        return ".eetpadA eht fo roivaheb laicepS"
```

#### Адаптер

```python
class Adapter(Target):
    """
    Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
    интерфейсом благодаря агрегации.
    """

    def __init__(self, adaptee: Adaptee) -> None:
        self.adaptee = adaptee

    def request(self) -> str:
        return f"Adapter: (TRANSLATED) {self.adaptee.specific_request()[::-1]}"
```

#### Модуль для тестирования

```python
def main():
    # Работа с объектом, реализующим Target
    target = ConcreteTarget()
    print("Клиент: Работаю с объектом Target:")
    print(target.request())

    # Работа с объектом Adaptee напрямую (интерфейс не подходит для клиента)
    adaptee = Adaptee()
    print("\nКлиент: У объекта Adaptee странный интерфейс:")
    print(adaptee.specific_request())

    # Использование адаптера для приведения интерфейса Adaptee к Target
    adapter = Adapter(adaptee)
    print("\nКлиент: Но через адаптер я могу работать с ним:")
    print(adapter.request())


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Повторное использование кода:** Позволяет использовать существующие классы с несовместимыми интерфейсами без
  изменения их кода.
- **Снижение связанности:** Клиентский код зависит только от интерфейса, а не от конкретных адаптируемых классов.
- **Гибкость:** Можно легко адаптировать новые системы или библиотеки без необходимости переписывать существующий код.
- **Упрощение интеграции:** Облегчает интеграцию сторонних библиотек или компонентов в проект.

### Недостатки данного паттерна

- **Усложнение структуры:** Добавляет дополнительный слой абстракции, что может увеличить сложность системы.
- **Избыточность:** В некоторых случаях может быть избыточным, особенно если интерфейсы могут быть изменены.
- **Надежность:** Требует тщательной реализации адаптера, чтобы избежать ошибок преобразования данных.

### Заключение

Паттерн проектирования Адаптер является мощным инструментом для интеграции различных компонентов и систем с
несовместимыми интерфейсами. Он позволяет сохранять существующий код неизменным, обеспечивая при этом гибкость и
расширяемость приложения. В стандартной Java библиотеке паттерн Адаптер широко используется для адаптации различных
интерфейсов и классов, обеспечивая удобство и типовую безопасность при работе с коллекциями, потоками ввода-вывода и
другими компонентами.

При правильном применении паттерн Адаптер способствует созданию более модульного, гибкого и поддерживаемого кода,
облегчая интеграцию новых технологий и систем без необходимости радикальных изменений в существующей архитектуре.
