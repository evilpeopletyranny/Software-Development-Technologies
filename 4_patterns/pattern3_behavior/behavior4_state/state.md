# State

## Состояние

**Состояние** — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от
своего состояния. Извне создаётся впечатление, что изменился класс объекта.

Паттерн схож с конечным автоматом и предназначен для избавления от множества if и switch операторов.
Проблема if и switch операторов заключается в их негибкости и нагромажденности. Зачастую множество if операторов лежит в
одном месте, что ещё больше усложняет понимает контекста. При паттерне **Состояние** особенности поведение переносят в
класс состояния, тем самым убирая множественно ветвление.

*Задумайтесь об использовании **Состояния** там, где у вас много if и switch операторов*.

#### Основная идея

Паттерн Состояние разделяет функциональность объекта на отдельные классы, каждый из которых представляет определенное
состояние. Контекст (объект, поведение которого изменяется) содержит ссылку на текущий объект-состояние и делегирует ему
выполнение соответствующих действий.

#### Применение

Паттерн Состояние рекомендуется использовать в следующих случаях:

- **Объект должен изменять свое поведение в зависимости от своего состояния:** Когда поведение объекта должно изменяться
  динамически при изменении его внутреннего состояния.
- **Сложные условные операторы:** Когда в классе много условных операторов (```if```, ```switch```), которые изменяют
  поведение в зависимости от состояния. Паттерн Состояние помогает избежать этого, разделяя поведение на отдельные
  классы.
- **Необходимо легко добавлять новые состояния:** Паттерн облегчает добавление новых состояний без изменения
  существующего кода контекста или других состояний.

### Реализация

1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже
   есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
2. Создайте интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
   Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
3. Для каждого фактического состояния, создайте класс, реализующий интерфейс состояния. Переместите весь код, связанный
   с конкретным состоянием в нужный класс. В конце концов, все методы интерфейса состояния должны быть реализованы.
4. Создайте в контексте поле для хранения объектов состояний, а также публичный метод для изменения значения этого поля.
5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов
   объекта-состояния.
6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо
   внутри классов конкретных состояний.

### Примеры

#### [Пример](code/main.py) со статусом посылки

```PackageState``` – абстрактный класс, задающий методы перехода в следующее (next()) и предыдущее (prev()) состояния, а
также метод print_status() для вывода информации о текущем состоянии.

```python
# Общий интерфейс (абстрактный класс) состояния посылки
class PackageState(ABC):
    @abstractmethod
    def next(self, pkg: Package) -> None:
        """Переход в следующее состояние."""
        pass

    @abstractmethod
    def prev(self, pkg: Package) -> None:
        """Переход в предыдущее состояние."""
        pass

    @abstractmethod
    def print_status(self) -> None:
        """Вывод статуса посылки."""
        pass

```

---

```OrderedState```, ```DeliveredState``` и ```ReceivedState``` – конкретные состояния, реализующие заданные методы.

```python

class OrderedState(PackageState):
    def next(self, pkg: Package) -> None:
        pkg.set_state(DeliveredState())

    def prev(self, pkg: Package) -> None:
        print("The package is in its root state.")

    def print_status(self) -> None:
        print("Package ordered, not delivered to the office yet.")


class DeliveredState(PackageState):
    def next(self, pkg: Package) -> None:
        pkg.set_state(ReceivedState())

    def prev(self, pkg: Package) -> None:
        pkg.set_state(OrderedState())

    def print_status(self) -> None:
        print("Package delivered to post office, not received yet.")


class ReceivedState(PackageState):
    def next(self, pkg: Package) -> None:
        print("This package is already received by a client.")

    def prev(self, pkg: Package) -> None:
        pkg.set_state(DeliveredState())

    def print_status(self) -> None:
        print("Package received.")

```

---

```Package``` – класс-контекст, который хранит текущее состояние и предоставляет методы для перехода между состояниями.

```python
# Контекст (посылка), изменяющий своё состояние
class Package:
    def __init__(self) -> None:
        # Начальное состояние – OrderedState
        self.state: PackageState = OrderedState()

    def set_state(self, state: PackageState) -> None:
        self.state = state

    def previous_state(self) -> None:
        self.state.prev(self)

    def next_state(self) -> None:
        self.state.next(self)

    def print_status(self) -> None:
        self.state.print_status()

```

---

Модуль для тестирования

```python
from package import Package


def main():
    pkg = Package()
    pkg.print_status()  # Должно вывести состояние OrderedState

    pkg.next_state()  # Переход к DeliveredState
    pkg.print_status()

    pkg.next_state()  # Переход к ReceivedState
    pkg.print_status()

    pkg.next_state()  # Попытка перейти за пределы состояния ReceivedState
    pkg.print_status()


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Упрощение кода:** Позволяет избавиться от сложных условных операторов (```if```, ```switch```) и заменяет их
  полиморфизмом.
- **Гибкость:** Легко добавлять новые состояния без изменения существующего кода контекста или других состояний.
- **Снижение связанности:** Контекст не знает деталей реализации состояний, что облегчает поддержку и расширение
  системы.
- **Легкость изменения состояний во время выполнения:** Состояние объекта может изменяться динамически в зависимости от
  событий или условий.

### Недостатки данного паттерна

- **Увеличение числа классов:** Каждый новый тип состояния требует создания отдельного класса, что может привести к
  большому количеству классов.
- **Сложность отладки:** Из-за разделения логики на разные классы может быть сложнее отследить поток выполнения
  программы.
- **Необходимость управления состояниями:** Нужно обеспечить правильное управление переходами между состояниями, что
  может усложнить дизайн системы.

### Заключение

Паттерн Состояние (State) предоставляет мощный способ управления поведением объектов в зависимости от их внутреннего
состояния. Он улучшает гибкость и расширяемость системы, позволяя легко добавлять новые состояния и изменять поведение
без изменения основного кода контекста.

При использовании паттерна Состояние важно тщательно проектировать интерфейсы и классы состояний, чтобы обеспечить
максимальную гибкость и минимальную связанность между компонентами системы.
