# Объектно-ориентированное программирование

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, в которой программная система моделируется как совокупность взаимодействующих объектов. Каждый объект является инкапсулированной сущностью, объединяющей в себе состояние (данные, представленные атрибутами) и поведение (функции или методы, осуществляющие операции над этими данными). Основополагающие принципы ООП – инкапсуляция, наследование, полиморфизм и абстракция – служат для распределения ответственности между компонентами системы, что способствует повышению модульности, повторному использованию кода и упрощению его сопровождения.

## Принципы ООП

- Инкапсуляция
- Наследование
- Полиморфизм
- Абстракция

## Инкапсуляция

**Инкапсуляция** – один из базовых принципов объектно-ориентированного программирования (ООП), который подразумевает объединение данных (атрибутов) и методов (функций), работающих с этими данными, внутри одного класса, а также сокрытие (скрытие) внутренней реализации от внешнего мира. Основные цели инкапсуляции:

- **Сокрытие деталей реализации**: Пользователь класса работает с его публичным интерфейсом, не вникая в детали реализации.
- **Защита данных**: Предотвращение нежелательного изменения внутренних состояний объекта.
- **Упрощение сопровождения и расширения кода**: Возможность изменения внутренней реализации без влияния на код, который использует этот класс.

В Python строгое сокрытие данных, как в некоторых других языках (например, private в Java или C++), отсутствует. Однако используются соглашения и механизмы, которые помогают реализовать инкапсуляцию:

### **Соглашение об именовании с одним подчёркиванием (```_attribute```):**

Это соглашение говорит о том, что атрибут или метод являются «защищёнными» (protected) и не предназначены для использования вне класса или его наследников. Однако на уровне языка доступ к таким атрибутам всё ещё возможен.

```Python
class Person:
    def __init__(self, name):
        self._name = name  # Атрибут помечен как "защищённый" по соглашению

    def get_name(self):
        return self._name

    def set_name(self, name):
        self._name = name

# Использование класса:
p = Person("Alice")
print(p.get_name())  # Выведет: Alice

# Несмотря на соглашение, можно обратиться напрямую:
print(p._name)  # Выведет: Alice, но делать так не рекомендуется
```

### **Манглирование имен (двойное подчёркивание ```__attribute```):**

При использовании двойного подчёркивания Python выполняет «манглирование» имени, что затрудняет случайный доступ к этим атрибутам извне. Несмотря на это, атрибут всё равно доступен (но уже через изменённое имя).

```Python
class Person:
    def __init__(self, name):
        self.__name = name  # Атрибут станет «приватным» благодаря манглированию имен

    def get_name(self):
        return self.__name

# Использование класса:
p = Person("Bob")
print(p.get_name())  # Выведет: Bob

# Попытка прямого доступа вызовет ошибку:
try:
    print(p.__name)
except AttributeError as e:
    print(e)  # Сообщение об ошибке: 'Person' object has no attribute '__name'

# Однако, благодаря манглированию, атрибут доступен через изменённое имя:
print(p._Person__name)  # Выведет: Bob

```

### **Использование свойств (```property```):**

С помощью декораторов ```@property```, ```@<имя_свойства>.setter``` и ```@<имя_свойства>.deleter``` можно управлять доступом к данным, позволяя выполнять дополнительную проверку или обработку при их получении или изменении.

Свойства позволяют инкапсулировать доступ к данным, при этом предоставляя интерфейс доступа, похожий на работу с обычными атрибутами. Это удобно, если нужно добавить валидацию или выполнить дополнительную обработку при чтении или записи значения.

```Python
class Person:
    def __init__(self, name):
        self.__name = name  # Приватный атрибут

    @property
    def name(self):
        """Геттер для атрибута name"""
        return self.__name

    @name.setter
    def name(self, value):
        """Сеттер для атрибута name с валидацией"""
        if not isinstance(value, str):
            raise ValueError("Имя должно быть строкой!")
        self.__name = value

    @name.deleter
    def name(self):
        """Делетер для атрибута name"""
        print("Удаление имени")
        del self.__name

# Использование класса:
p = Person("Charlie")
print(p.name)  # Использование геттера: Выведет "Charlie"

p.name = "Dave"  # Использование сеттера
print(p.name)    # Выведет "Dave"

# Попытка установить невалидное значение
try:
    p.name = 123
except ValueError as e:
    print(e)  # Выведет: Имя должно быть строкой!

# Удаление атрибута через делетер
del p.name
```

## Наследование

**Наследование** – один из ключевых принципов объектно-ориентированного программирования (ООП). Оно позволяет создавать новый класс (наследник или подкласс) на основе уже существующего класса (родитель или базовый класс). Это способствует повторному использованию кода, упрощает расширение функциональности и создание иерархий классов.
