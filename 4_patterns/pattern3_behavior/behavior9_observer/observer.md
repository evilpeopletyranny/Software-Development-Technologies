# Observer

## Наблюдатель

Паттерн **Observer (Наблюдатель)** — это поведенческий паттерн проектирования, который используется, когда один объект
должен автоматически уведомлять другой объект о любых изменениях его состояния. Этот паттерн реализует принцип "один ко
многим" и позволяет объекту (называемому наблюдаемый или subject) уведомлять подписанные на него объекты (наблюдатели)
об изменениях, не раскрывая своей внутренней структуры.

#### Основная идея

Паттерн Наблюдатель разделяет объекты на **наблюдаемые** (subjects) и **наблюдатели** (observers). Наблюдаемые объекты
управляют списком наблюдателей и уведомляют их об изменениях своего состояния. Наблюдатели реализуют интерфейс, который
позволяет им реагировать на эти уведомления.

#### Применение

Паттерн Наблюдатель используется в следующих случаях:

- Необходимо обеспечить автоматическое обновление множества объектов при изменении состояния одного объекта.
- Хочется поддерживать слабую связанность между объектами, чтобы изменения в одном объекте не требовали изменений в
  других.
- Необходимо поддерживать одну из архитектурных моделей типа MVC (Model-View-Controller), где модель должна уведомлять
  виды об изменениях.
- Когда количество наблюдателей может динамически изменяться во время выполнения программы.

### Реализация

1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро
   станет издателем. Зависимые части станут подписчиками.
2. Создайте интерфейс подписчиков. Обычно, в нём достаточно определить единственный метод оповещения.
3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать
   только с общим интерфейсом подписчиков.
4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый
   очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.
5. Создайте классы конкретных издателей. Реализуйте их так, чтобы при каждом изменении состояния, они слали оповещения
   всем своим подписчикам.
6. Реализуйте метод оповещения в конкретных подписчиках. Издатель может отправлять какие-то данные вместе с
   оповещением (например, в параметрах). Возможен и другой вариант, когда подписчик, получив оповещение, сам берёт из
   объекта издателя нужные данные. Но при этом подписчик привяжет себя к конкретному классу издателя.
7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

### Примеры

#### [Пример](code/main.py) реализации наблюдателя

**Observer (абстрактный класс**): Определяет метод ```update(temperature)```, который вызывается при изменении
температуры.

```python
# Интерфейс Observer
class Observer(ABC):
    @abstractmethod
    def update(self, temperature: float) -> None:
        pass
```

---

**Subject (абстрактный класс)**: Задает методы для добавления, удаления и уведомления наблюдателей.

```python
# Интерфейс Subject
class Subject(ABC):
    @abstractmethod
    def add_observer(self, observer: Observer) -> None:
        pass

    @abstractmethod
    def remove_observer(self, observer: Observer) -> None:
        pass

    @abstractmethod
    def notify_observers(self) -> None:
        pass
```

---

**TemperatureSensor**: Реализует интерфейс ```Subject```; при изменении температуры (метод ```set_temperature```)
уведомляет всех наблюдателей.

```python
# Конкретный Subject: датчик температуры
class TemperatureSensor(Subject):
    def __init__(self) -> None:
        self._observers: list[Observer] = []
        self._temperature: float = 0.0

    def add_observer(self, observer: Observer) -> None:
        self._observers.append(observer)

    def remove_observer(self, observer: Observer) -> None:
        if observer in self._observers:
            self._observers.remove(observer)

    def notify_observers(self) -> None:
        for observer in self._observers:
            observer.update(self._temperature)

    def set_temperature(self, temperature: float) -> None:
        self._temperature = temperature
        self.notify_observers()

    def get_temperature(self) -> float:
        return self._temperature
```

---

**Alarm**: Реализует интерфейс ```Observer``` и выводит сообщение тревоги, если температура превышает 30°C.

```python
# Конкретный Observer: Alarm
class Alarm(Observer):
    def update(self, temperature: float) -> None:
        if temperature > 30.0:
            print(f"Сигнал тревоги! Высокая температура: {temperature}°C")
```

---

**Display**: Реализует интерфейс ```Observer``` и выводит сообщение с текущей температурой.

```python

# Конкретный Observer: Display
class Display(Observer):
    def __init__(self, name: str) -> None:
        self.name = name

    def update(self, temperature: float) -> None:
        print(f"Дисплей {self.name} отображает температуру: {temperature}°C")
```

---

**main()**: Создает экземпляр датчика, регистрирует наблюдателей и изменяет температуру, что приводит к уведомлению всех
наблюдателей.

```python
from observer import TemperatureSensor, Display, Alarm


# Клиентский код
def main():
    sensor = TemperatureSensor()

    # Создаем наблюдателей
    display1 = Display("1")
    display2 = Display("2")
    alarm = Alarm()

    # Подписываем наблюдателей на датчик
    sensor.add_observer(display1)
    sensor.add_observer(display2)
    sensor.add_observer(alarm)

    # Изменяем состояние датчика
    sensor.set_temperature(25.0)
    sensor.set_temperature(28.5)
    sensor.set_temperature(32.0)


if __name__ == "__main__":
    main()

```

### Плюсы данного паттерна

- **Снижение связанности между объектами:** Наблюдатели и наблюдаемый не зависят напрямую друг от друга, взаимодействуя
  через интерфейсы. Это облегчает изменение и расширение системы.
- **Удобство добавления новых наблюдателей:** Новые типы наблюдателей могут быть добавлены без изменения кода
  наблюдаемого объекта.
- **Поддержка динамического взаимодействия:** Наблюдатели могут добавляться и удаляться во время выполнения программы.
- **Повторное использование кода:** Один и тот же наблюдаемый объект может иметь множество наблюдателей с различным
  поведением.

### Недостатки данного паттерна

- **Неопределенность порядка уведомлений:** Порядок, в котором наблюдатели получают уведомления, может быть
  неопределенным, что может привести к непредсказуемому поведению.
- **Потенциальные проблемы с производительностью:** Если наблюдаемых много, а их обновления часты, это может привести к
  ухудшению производительности.
- **Риск утечек памяти:** Неправильное управление подписками (например, не удаление наблюдателей) может привести к
  утечкам памяти.
- **Сложность отладки:** Множество наблюдателей может усложнить отслеживание источников проблем при изменениях
  состояний.

### Заключение

**Паттерн Наблюдатель (Observer)** является мощным инструментом для создания гибких и расширяемых систем, позволяя
объектам взаимодействовать между собой без жесткой связанности. Он широко используется в различных областях разработки,
таких как пользовательские интерфейсы, системы уведомлений и реактивное программирование.

Однако, как и любой паттерн, **Observer** имеет свои ограничения и должен использоваться осознанно, учитывая особенности
конкретного проекта и его требований.
