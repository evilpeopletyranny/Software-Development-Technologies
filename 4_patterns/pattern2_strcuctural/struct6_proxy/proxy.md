# Proxy

## Заместитель

**Прокси** — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов
специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или
после передачи вызова оригиналу.

В разработке программного обеспечения часто возникает необходимость контролировать доступ к объектам, добавлять
дополнительную функциональность или управлять ресурсами. Структурный паттерн проектирования **Прокси** (Proxy)
предоставляет решение для этих задач, позволяя создавать заместителей (прокси) для других объектов. Прокси выступает в
роли посредника между клиентом и реальным объектом, перехватывая и управляя вызовами методов.

#### Основная идея

Основная идея паттерна Прокси заключается в том, чтобы предоставить объект-прокси, который имеет тот же интерфейс, что и
реальный объект, и управляет доступом к нему. Это позволяет внедрять дополнительные функциональности и контролировать
взаимодействие с реальным объектом.

#### Применение

1. **"Виртуальный прокси"** - ленивая инициализация. Позволяет отложить создание тяжелого объекта до
   необходимости/обращения. Загрузка больших объектов на старте программы может суещсвтенно повлиять на запуск по
   времени и памяти.
2. **"Защищающий прокси"** - разграничение доступа к объекту/части системы. Через прокси реализуются методы проверки.
3. **"Умный прокси/умная ссылка"** - когда необходимо кэшировать результаты запросов клиентов и управлять их жизненным
   циклом.
4. **"Удаленный прокси"** - прокси транслирует запросы клиента в виде понятном удаленными сервису.
5. **"Логирующий прокси"** - хранит историю обращений к сервисному объекту.
6. **"Синхронизирующий прокси"** - проверка доступа к разделяемому ресурсу
7. и тд. Примеров ещё не мало.

### Реализация

1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся
   самим заместителем. В редких случаях, заместитель получает готовый сервисный объект от клиента через конструктор.
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какуюто полезную
   работу, методы заместителя должны передать запрос сервисному объекту.
4. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам
   заместителя.

### Примеры

#### [main.py](code/main.py) кэширующего прокси

```python
# Интерфейс сервиса
class DataService(ABC):
    @abstractmethod
    def fetch_data(self, parameter: str) -> str:
        pass
```

```python
# Реальная реализация сервиса
class DataServiceImpl(DataService):
    def fetch_data(self, parameter: str) -> str:
        self.simulate_expensive_operation()
        return f"Data for {parameter}"

    def simulate_expensive_operation(self):
        print("Fetching data from external source...")
        time.sleep(3)  # Симуляция задержки 3 секунды
```

```python
# Прокси с кэшированием, который инициализирует реальный сервис внутри себя
class CachingDataServiceProxy(DataService):
    def __init__(self):
        self.real_data_service = DataServiceImpl()  # Создаем реальный сервис внутри прокси
        self.cache = {}

    def fetch_data(self, parameter: str) -> str:
        if parameter in self.cache:
            print(f"Returning cached data for: {parameter}")
            return self.cache[parameter]
        print(f"No cache found for: {parameter}. Fetching data...")
        data = self.real_data_service.fetch_data(parameter)
        self.cache[parameter] = data
        return data
```

```python
from proxy import CachingDataServiceProxy


# Клиентский код
def main():
    # Создаем прокси без передачи реального сервиса
    caching_proxy = CachingDataServiceProxy()

    print("First request:")
    data1 = caching_proxy.fetch_data("param1")
    print("Received:", data1, "\n")

    print("Second request:")
    data2 = caching_proxy.fetch_data("param1")
    print("Received:", data2, "\n")

    print("Third request:")
    data3 = caching_proxy.fetch_data("param2")
    print("Received:", data3, "\n")

    print("Fourth request:")
    data4 = caching_proxy.fetch_data("param2")
    print("Received:", data4)


if __name__ == "__main__":
    main()

```

### Плюсы данного паттерна

- **Контроль доступа:** Прокси может контролировать доступ к реальному объекту, реализуя механизмы аутентификации или
  авторизации.
- **Добавление функциональности:** Позволяет динамически добавлять новые поведения (например, логирование, кэширование)
  без изменения реального объекта.
- **Ленивая инициализация:** Прокси может создавать реальный объект только при необходимости, экономя ресурсы.
- **Упрощение интерфейсов:** Прокси может предоставлять упрощённый интерфейс к сложной подсистеме, снижая связанность
  между компонентами.
- **Безопасность:** Прокси может защищать реальный объект от некорректного использования клиентами.

### Недостатки данного паттерна

- **Увеличение сложности системы:** Введение прокси добавляет дополнительный уровень абстракции, что может усложнить
  архитектуру приложения.
- **Потенциальная задержка:** Дополнительные вызовы методов через прокси могут привести к незначительным задержкам в
  производительности.
- **Сложность отладки:** Множественные уровни прокси могут затруднить процесс отладки и отслеживания проблем в системе.
- **Необходимость поддержки прокси:** Изменения в реальном объекте могут потребовать обновления прокси для корректного
  взаимодействия.

### Заключение

Паттерн проектирования Прокси является мощным инструментом для управления доступом к объектам, добавления дополнительной
функциональности и оптимизации использования ресурсов.

Правильное применение паттерна Прокси способствует созданию более гибкой, расширяемой и безопасной архитектуры
приложений. Однако, необходимо учитывать возможные недостатки, такие как увеличение сложности и потенциальные задержки,
чтобы эффективно использовать этот паттерн в своих проектах.
