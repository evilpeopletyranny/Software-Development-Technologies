# Flyweight

## Легковес

**Легковес** — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в
отведённую оперативной память за счёт экономного разделения общего состояния объектов между собой, вместо хранения
одинаковых данных в каждом объекте.

В разработке программного обеспечения часто сталкиваются с задачами управления большим количеством объектов, которые
могут иметь схожие характеристики. Это приводит к увеличению потребления памяти и снижению производительности системы.
Структурный паттерн проектирования **Легковес** (Flyweight) предоставляет решение этой проблемы, позволяя эффективно
использовать память за счёт разделения общих (внутренних) и уникальных (внешних) данных объектов.

#### Основная идея

Основная идея паттерна Легковес заключается в разделении состояния объекта на внутреннее (shared) и внешнее (unshared).
Внутреннее состояние хранится в одном экземпляре и разделяется между всеми объектами, а внешнее состояние передаётся
клиенту и хранится отдельно.

#### Применение

Паттерн Легковес рекомендуется использовать в следующих случаях:

- Необходимо создать большое количество мелких объектов, расходующих много памяти.
- Объекты могут иметь общие части состояния, которые могут быть разделены между ними.
- Хотите уменьшить количество создаваемых объектов для повышения производительности.
- Требуется обеспечить разделение внутреннего и внешнего состояния объектов.

### Реализация

1. Разделите поля класса, который станет легковесом, на две части:
    - внутреннее состояние: значения этих полей одинаковы для большого числа объектов
    - внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояние в классе, но убедитесь, что их значения неизменяемы. Эти поля должны
   инициализироваться только через конструктор.
3. Превратите поля внешнего состояния в аргументы методов, где эти поля использовались. Затем, удалите поля из класса
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен запрашивать
   легковеса с определённым внутренним состоянием из этой фабрики, а не создавать его напрямую
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта
   легковеса.

### Примеры

#### [Пример](code/main.py) паттерна легковес при разработке текстового редактора

```python
# Вспомогательный класс для хранения внешнего состояния
class CharacterContext:
    def __init__(self, x: int, y: int) -> None:
        self.x = x
        self.y = y


# Интерфейс Flyweight
class CharacterFlyweight(ABC):
    @abstractmethod
    def display(self, context: CharacterContext) -> None:
        pass
```

```ConcreteCharacterFlyweight``` хранит внутреннее состояние: символ, шрифт и размер.

```python
# Конкретная реализация Flyweight
class ConcreteCharacterFlyweight(CharacterFlyweight):
    def __init__(self, character: str, font: str, size: int) -> None:
        self.character = character
        self.font = font
        self.size = size

    def display(self, context: CharacterContext) -> None:
        print(f"Character: {self.character}, Font: {self.font}, Size: {self.size}, "
              f"Position: ({context.x}, {context.y})")
```

```CharacterFlyweightFactory``` управляет созданием и хранением экземпляров ```ConcreteCharacterFlyweight```. Если
необходимый экземпляр уже существует, он возвращается из кэша.

```python
# Фабрика Flyweight, которая хранит созданные объекты в словаре
class CharacterFlyweightFactory:
    _flyweights = {}

    @classmethod
    def get_character(cls, character: str, font: str, size: int) -> CharacterFlyweight:
        key = f"{character}-{font}-{size}"
        if key not in cls._flyweights:
            cls._flyweights[key] = ConcreteCharacterFlyweight(character, font, size)
            print(f"Creating new Flyweight for: {key}")
        return cls._flyweights[key]

    @classmethod
    def get_flyweight_count(cls) -> int:
        return len(cls._flyweights)

```

```CharacterContext``` содержит внешнее состояние: позицию символа в тексте.

```python
from flyweight import CharacterFlyweightFactory, CharacterContext


# Клиентский код (аналог FlyweightPatternMain.java)
def main():
    text = "HELLO HELLO"
    font = "Arial"
    size = 12

    x = 0
    y = 0

    for c in text:
        flyweight = CharacterFlyweightFactory.get_character(c, font, size)
        context = CharacterContext(x, y)
        flyweight.display(context)
        x += 10  # увеличение позиции по оси X

    print("Total Flyweight objects created:", CharacterFlyweightFactory.get_flyweight_count())


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Экономия памяти:** Позволяет уменьшить количество создаваемых объектов за счёт повторного использования существующих
  экземпляров.
- **Повышение производительности:** Снижение нагрузки на систему благодаря уменьшению объёмов памяти и ускорению доступа
  к кэшированным объектам.
- **Гибкость:** Легко добавлять новые типы объектов без изменения существующего кода.
- **Упрощение управления объектами:** Централизованное управление экземплярами через фабрику или кэш.

### Недостатки данного паттерна

- **Сложность реализации**: Требует дополнительного кода для управления кэшем и разделения состояния.
- **Сложность управления состоянием:** Необходимо чётко разделять внутреннее и внешнее состояние, чтобы избежать ошибок
  при повторном использовании объектов.
- **Потенциальные проблемы с синхронизацией:** В многопоточных приложениях необходимо обеспечить корректное управление
  доступом к кэшу.

### Заключение

Паттерн проектирования Легковес является эффективным инструментом для оптимизации использования памяти и повышения
производительности приложений, особенно при работе с большим количеством схожих объектов.

Однако, как и любой паттерн, Легковес должен применяться осознанно, учитывая требования и специфику проекта.
Неправильное разделение состояния или управление кэшем может привести к ошибкам и ухудшению производительности.

Понимание и правильное применение паттерна Легковес способствует созданию более эффективных и масштабируемых систем,
снижая потребление ресурсов и улучшая общую производительность приложения.
