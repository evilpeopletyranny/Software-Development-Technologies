# Object Pool

## Пул объектов

**Пул объектов** — это **порождающий** паттерн проектирования, который предоставляет способ управления набором
предварительно созданных объектов, готовых к использованию. Вместо создания новых объектов каждый раз, когда они
необходимы, объекты берутся из пула и возвращаются обратно после использования. Это особенно полезно для объектов,
создание которых дорогостоящее или ресурсоёмкое, например, соединения к базе данных, потоки, сетевые соединения и т.д.

#### Основная идея

Основная идея паттерна Пул объектов заключается в том, чтобы создать ограниченный набор объектов заранее и управлять их
использованием. Когда клиенту требуется объект, он берёт его из пула. После использования объект возвращается в пул для
повторного использования.

#### Применение

Паттерн Пул объектов рекомендуется использовать в следующих случаях:

- **Создание объектов ресурсоёмкое**: Когда создание объектов требует значительных затрат времени или ресурсов (
  например, подключение к базе данных).
- **Необходимость повторного использования объектов**: Когда объекты могут быть переиспользованы без изменения их
  состояния или при минимальном изменении.
- **Ограничение количества экземпляров**: Когда необходимо ограничить количество одновременно используемых объектов для
  предотвращения исчерпания ресурсов.

### Пример

```python
import threading
import queue
import time


# Пример ресурса, который будем переиспользовать
class Connection:
    def __init__(self, id):
        self.id = id

    def connect(self):
        print(f"Connection {self.id} established.")

    def disconnect(self):
        print(f"Connection {self.id} closed.")

    def __str__(self):
        return f"Connection({self.id})"


# Реализация Object Pool
class ObjectPool:
    def __init__(self, create_instance, max_size=5):
        """
        create_instance: функция для создания нового экземпляра ресурса.
        max_size: максимальное число объектов в пуле.
        """
        self._pool = queue.Queue(maxsize=max_size)
        self._create_instance = create_instance
        self._lock = threading.Lock()
        self._counter = 0

        # Опционально можно заранее создать объекты пула.
        for _ in range(max_size):
            self._pool.put(self._create_instance(self._next_id()))

    def _next_id(self):
        with self._lock:
            self._counter += 1
            return self._counter

    def acquire(self):
        """
        Получает объект из пула. Если пул пуст, создаётся новый объект.
        """
        try:
            obj = self._pool.get(block=False)
            print(f"Acquired {obj} from pool.")
            return obj
        except queue.Empty:
            new_obj = self._create_instance(self._next_id())
            print(f"Pool empty. Created new {new_obj}.")
            return new_obj

    def release(self, obj):
        """
        Возвращает объект в пул. Если пул полон, объект закрывается (или удаляется).
        """
        try:
            self._pool.put(obj, block=False)
            print(f"Released {obj} back to pool.")
        except queue.Full:
            # Если пул полон, можно закрыть ресурс или просто отбросить его.
            obj.disconnect()
            print(f"Pool full. {obj} was closed.")


# Функция для создания нового соединения
def create_connection(id):
    conn = Connection(id)
    conn.connect()
    return conn


# Пример использования Object Pool
def main():
    pool = ObjectPool(create_connection, max_size=3)

    # Получаем несколько соединений из пула
    conn1 = pool.acquire()
    conn2 = pool.acquire()

    # Используем соединения...
    time.sleep(1)

    # Возвращаем соединения обратно в пул
    pool.release(conn1)
    pool.release(conn2)

    # Получаем ещё одно соединение
    conn3 = pool.acquire()
    pool.release(conn3)


if __name__ == "__main__":
    main()

```

### Плюсы данного паттерна

- **Повышение производительности**: Сокращает время на создание и уничтожение объектов, особенно если это ресурсоёмкие
  операции.
- **Эффективное использование ресурсов**: Позволяет ограничить количество одновременно используемых объектов,
  предотвращая исчерпание ресурсов.
- **Управление ресурсами**: Обеспечивает централизованный контроль над использованием объектов.
- **Снижение нагрузки на систему**: Уменьшает количество операций создания и уничтожения объектов, снижая нагрузку на
  сборщик мусора.

### Недостатки данного паттерна

- **Сложность реализации**: Требует дополнительной логики для управления пулом, что может увеличить сложность кода.
- **Необходимость управления состоянием объектов**: Объекты должны быть готовы к повторному использованию, что может
  требовать реализации методов сброса или инициализации.
- **Проблемы с потокобезопасностью**: В многопоточной среде необходимо обеспечить синхронизацию доступа к пулу, что
  может привести к снижению производительности.
- **Скрытые зависимости**: Клиентский код зависит от пула объектов, что может усложнить тестирование и модульность.
