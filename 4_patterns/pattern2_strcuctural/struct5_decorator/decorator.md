# Decorator

## Декоратор

**Декоратор** — это структурный паттерн проектирования, который позволяет динамически менять функциональность объектов,
оборачивая их в полезные «обёртки».

Паттерн декоратор является лучшим примером когда использование композиции превосходит наследование.

В разработке программного обеспечения часто возникает необходимость динамически добавлять объектам новые функциональные
возможности без изменения их структуры. Паттерн проектирования **Декоратор** (Decorator) предоставляет гибкое решение
этой задачи, позволяя расширять поведение объектов путем оборачивания их в дополнительные компоненты.

## Важно!

**Не путайте понятие паттерна декоратор и такой языковой конструкции Python как декоратор.**

#### Основная идея

Основная идея паттерна Декоратор заключается в том, чтобы предоставить способ оборачивания объектов для добавления новых
функций, сохраняя при этом интерфейс исходного объекта. Это позволяет клиентам взаимодействовать с декорированными
объектами так же, как с оригинальными, не зная о дополнительном функционале.

#### Применение

Примеры, когда можно использовать паттерн декоратор:

1. Когда вы хотите добавить, улучшить или, возможно, удалить поведение или состояние объекта.
2. Когда вам нужно изменять обязанности объектам на лету, незаметно для кода, который их использует.
3. Когда нельзя расширить обязанности объекта с помощью наследования.
4. Когда вы просто хотите изменить функциональность одного конкретного объекта класса, а остальные оставить без
   изменений

### Реализация

1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
2. Создайте интерфейс компонента, который описывал бы все общие методы как для основного компонента, так и для его
   дополнений.
3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику
4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все
   методы базового декоратора должны делегировать действие вложенному объекту.
5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен
   выполнять свою добавочную функциональность, а затем   (или перед этим) вызывать эту же операцию обёрнутого объекта.
7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

### Примеры

#### [Пример](code%2Fmain.py) работы с сообщениями

Базовый интерфейс ```Message```

```python
from abc import ABC, abstractmethod


# Интерфейс Message
class Message(ABC):
    @abstractmethod
    def get_content(self) -> str:
        pass

```

Конкретный компонент ```SimpleMessage```

```python
# Конкретная реализация сообщения
class SimpleMessage(Message):
    def __init__(self, content: str) -> None:
        self.content = content

    def get_content(self) -> str:
        return self.content
```

Абстрактный декоратор ```MessageDecorator```

```python
# Базовый декоратор, реализующий интерфейс Message
class MessageDecorator(Message):
    def __init__(self, message: Message) -> None:
        self.message = message

    def get_content(self) -> str:
        return self.message.get_content()

```

Декоратор для шифрования сообщения

```python
# Декоратор, добавляющий шифрование (в данном случае – разворот строки)
class EncryptedMessageDecorator(MessageDecorator):
    def __init__(self, message: Message) -> None:
        super().__init__(message)

    def get_content(self) -> str:
        return self.encrypt(self.message.get_content())

    def encrypt(self, content: str) -> str:
        # Простая симуляция шифрования: разворот строки
        return content[::-1]
```

```python
# Декоратор, добавляющий временную метку
class TimestampedMessageDecorator(MessageDecorator):
    def __init__(self, message: Message) -> None:
        super().__init__(message)

    def get_content(self) -> str:
        return self.add_timestamp(self.message.get_content())

    def add_timestamp(self, content: str) -> str:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"[{timestamp}] {content}"

```

```python
def main():
    # Создание простого сообщения
    simple_message = SimpleMessage("Hello, World!")
    print("Simple Message:", simple_message.get_content())

    # Добавление шифрования
    encrypted_message = EncryptedMessageDecorator(simple_message)
    print("Encrypted Message:", encrypted_message.get_content())

    # Добавление временной метки
    timestamped_message = TimestampedMessageDecorator(simple_message)
    print("Timestamped Message:", timestamped_message.get_content())

    # Комбинирование декораторов: сначала шифрование, затем добавление метки
    encrypted_timestamped_message = TimestampedMessageDecorator(encrypted_message)
    print("Encrypted & Timestamped Message:", encrypted_timestamped_message.get_content())


if __name__ == "__main__":
    main()
```

## Паттерн декоратор и декоратор Python

**Паттерн «Декоратор»** – это структурный паттерн проектирования, который позволяет динамически добавлять объектам новые
обязанности (поведение), оборачивая их в специальные объекты‑декораторы. Его цель – расширять функциональность объектов
без изменения их класса и без использования наследования.

**Декораторы в Python** – это синтаксическая конструкция (с использованием знака ```@```), которая позволяет
модифицировать функции, методы или классы. Они представляют собой функции или классы, принимающие другую функцию (или
класс) и возвращающие «обёрнутую» версию с изменённым поведением.

### Основные отличия:

**Уровень абстракции:**

- **Паттерн декоратор** описывает способ динамического расширения поведения конкретных объектов, обычно посредством
  композиции (обёртывания объекта в другой объект).
- **Декораторы в Python** – это язык‑функциональность, которая может применяться к функциям, методам или классам для
  модификации их поведения на этапе определения.

**Реализация:**

- В классическом **паттерне декоратор** создаются отдельные классы‑обёртки, реализующие тот же интерфейс, что и
  декорируемый
  объект, и делегирующие вызовы оригинальному объекту, добавляя свою логику.
- **Декораторы в Python** – это функции (или классы), которые принимают другую функцию и возвращают новую функцию (или
  объект класса) с модифицированным поведением.

### Плюсы данного паттерна

- **Гибкость:** Позволяет динамически добавлять функциональность объектам без изменения их структуры.
- **Повторное использование кода:** Позволяет комбинировать различные декораторы для создания сложного поведения.
- **Снижение связанности:** Клиентский код взаимодействует с объектами через общий интерфейс, не зная о конкретных
  декораторах.
- **Прозрачность для клиента:** Клиент не осознает, что объект был декорирован, взаимодействуя с ним как с обычным
  компонентом.

### Недостатки данного паттерна

- **Увеличение числа классов:** Каждый новый декоратор требует создания отдельного класса, что может привести к росту
  количества классов в проекте.
- **Сложность отладки:** Множественные обертки могут усложнить процесс отладки и отслеживания поведения объектов.
- **Потенциальные конфликты:** Некорректное использование декораторов может привести к конфликтам в функциональности или
  порядку вызовов методов.

### Заключение

Паттерн проектирования Декоратор является мощным инструментом для динамического расширения функциональности объектов без
изменения их структуры. Он широко применяется в стандартной библиотеке Java, особенно в области ввода-вывода и
графического интерфейса, обеспечивая гибкость и модульность систем.

Правильное применение паттерна Декоратор способствует созданию более гибких и расширяемых систем, облегчая добавление
новых функциональностей и поддержание кода. Однако, необходимо учитывать возможные недостатки, такие как увеличение
числа классов и усложнение отладки, чтобы эффективно использовать этот паттерн в своих проектах.

### Источники

- Design Patterns with Java: Decorator
- Введение в паттерны проектирования: Декоратор