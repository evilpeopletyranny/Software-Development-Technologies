# Multiton

## Мультитон

Паттерн **Мультитон (Multiton)** представляет собой расширение паттерна **Синглтон (Singleton)**, позволяющее управлять
созданием нескольких экземпляров класса, каждый из которых ассоциирован с уникальным ключом. Это позволяет создавать и
контролировать доступ к ограниченному набору экземпляров, обеспечивая при этом их единственность по ключу.

**Мультитон** — это **порождающий** паттерн проектирования, который управляет созданием и доступом к нескольким
экземплярам класса, каждый из которых идентифицируется уникальным ключом. В отличие от Синглтона, который гарантирует
существование только одного экземпляра класса, Мультитон позволяет создавать ограниченное число экземпляров, доступных
по определённым идентификаторам.

#### Основная идея

Основная идея паттерна Мультитон заключается в том, чтобы контролировать создание экземпляров класса, гарантируя, что
для каждого уникального ключа существует только один экземпляр. Это позволяет эффективно управлять ресурсами и
обеспечивать согласованность данных в рамках разных контекстов.

#### Применение

Паттерн Мультитон рекомендуется использовать в следующих случаях:

- **Необходимость управления ограниченным набором экземпляров класса**: Например, управление соединениями к различным
  базам данных, настройками для разных регионов и т.д.
- **Обеспечение единственности экземпляра по ключу**: Когда требуется, чтобы для каждого уникального идентификатора
  существовал только один экземпляр объекта.
- **Управление ресурсами**: Позволяет эффективно использовать ресурсы, избегая создания избыточных объектов.
- **Согласованность данных**: Гарантирует, что данные в рамках определённого контекста остаются консистентными

### Структура паттерна Мультитон

Паттерн Мультитон включает в себя следующие компоненты:

- Multiton (Мультитон):
    - **Описание**: Класс, реализующий паттерн Мультитон, который управляет созданием и хранением экземпляров.
    - **Особенности**:
        - Приватный конструктор для предотвращения создания экземпляров извне.
        - Статическая коллекция (например, Map) для хранения экземпляров по ключам.
        - Статический метод доступа, принимающий ключ и возвращающий соответствующий экземпляр.

### Примеры

#### [Пример](code/main.py) с фабриками фигур

Предположим, у нас есть различные фигуры: ```Circle```, ```Rectangle``` и ```Triangle```. Для каждой фигуры необходимо
иметь соответствующую фабрику (CircleFactory, RectangleFactory, TriangleFactory), которая отвечает за создание
экземпляров этой фигуры. Используя паттерн Мультитон, мы можем управлять этими фабриками, обеспечивая, что для каждой
фигуры существует только одна фабрика.

##### Интерфейс Продукта

```python
class Shape(ABC):
    @abstractmethod
    def draw(self) -> None:
        """Рисует фигуру."""
        pass
```

##### Конкретные продукты

```python
class Circle(Shape):
    def __init__(self, name: str):
        self.name = name

    def draw(self) -> None:
        print(f"Рисование круга: {self.name}")


class Rectangle(Shape):
    def __init__(self, name: str):
        self.name = name

    def draw(self) -> None:
        print(f"Рисование прямоугольника: {self.name}")


class Triangle(Shape):
    def __init__(self, name: str):
        self.name = name

    def draw(self) -> None:
        print(f"Рисование треугольника: {self.name}")

```

##### Интерфейс Фабрики

```python
from shape import *


class ShapeFactory(ABC):
    @abstractmethod
    def create_shape(self, name: str) -> Shape:
        """Создаёт фигуру с заданным именем."""
        pass

```

##### Конкретные фабрики

```python
class CircleFactory(ShapeFactory):
    def create_shape(self, name: str) -> Shape:
        return Circle(name)


class RectangleFactory(ShapeFactory):
    def create_shape(self, name: str) -> Shape:
        return Rectangle(name)


class TriangleFactory(ShapeFactory):
    def create_shape(self, name: str) -> Shape:
        return Triangle(name)
```

##### Мультитон

```python
class ShapeType(Enum):
    CIRCLE = 1
    RECTANGLE = 2
    TRIANGLE = 3


class ShapeFactoryMultiton:
    # Инициализация единственных экземпляров фабрик для каждого типа фигуры
    _instances = {
        ShapeType.CIRCLE: CircleFactory(),
        ShapeType.RECTANGLE: RectangleFactory(),
        ShapeType.TRIANGLE: TriangleFactory()
    }

    @classmethod
    def get_instance(cls, shape_type: ShapeType):
        """
        Возвращает единственный экземпляр фабрики для указанного типа фигуры.
        """
        return cls._instances.get(shape_type)
```

### Плюсы данного

- **Контроль над количеством экземпляров**: Позволяет ограничить количество экземпляров класса, обеспечивая
  единственность для каждого ключа.
- **Гибкость и расширяемость**: Легко добавлять новые типы экземпляров без изменения существующего кода.
- **Эффективное управление ресурсами**: Избегает избыточного создания объектов, что может быть важно при работе с
  ресурсозатратными объектами (например, соединениями к базе данных).
- **Согласованность данных**: Гарантирует, что все части программы используют одни и те же экземпляры для одного ключа,
  обеспечивая консистентность данных.

### Недостатки данного паттерна

- **Сложность реализации**: Требует дополнительной логики для управления экземплярами и ключами.
- **Скрытые зависимости**: Клиентский код зависит от конкретных ключей, что может усложнить понимание зависимостей и
  тестирование.
- **Проблемы с тестированием**: Могут возникнуть сложности при написании юнит-тестов из-за глобального состояния и
  управляемого количества экземпляров.
- **Необходимость управления жизненным циклом**: Требует дополнительных механизмов для управления жизненным циклом и
  уничтожением экземпляров, если это необходимо.
