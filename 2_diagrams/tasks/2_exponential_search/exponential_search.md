# Задание: сделать блок-схему по представленному коду

## Экспоненциальный поиск

**Экспоненциальный поиск** имеет временную сложность ```O(log n)``` в худшем случае, что сопоставимо с **бинарным
поиском**. Однако его ключевое преимущество заключается в том, что он способен эффективно работать с неограниченными или
очень большими отсортированными массивами, когда заранее неизвестны границы поиска.

### Очень кратко

Надстройка над бинарным поиском, где сначала уменьшается диапазон поиска.

### Основные моменты

- Также работает только на отсортированных данных
- Экспоненциальный поиск сначала находит диапазон, в котором может находиться искомый элемент, увеличивая индекс
  экспоненциально (то есть ```O(log i)```, где ```i``` – индекс элемента).
- Затем внутри найденного диапазона выполняется бинарный поиск, что также имеет сложность ```O(log i)```.
- В худшем случае сложность алгоритма становится ```O(log n)```, где ```n``` – количество элементов в массиве.

### Преимущества

- **Работа с неограниченными структурами:** Экспоненциальный поиск может быть реализован таким образом, что позволяет
  работать с заранее не известным или условно бесконечным массивом данных  (например, поток данных или "бесконечный"
  массив). Экспоненциальный поиск позволяет сначала найти верхнюю границу, где искомый элемент может находиться, а затем
  применить бинарный поиск.
- **Адаптивность:**сли искомый элемент находится в начале массива, экспоненциальный поиск может обнаружить его очень
  быстро, не просматривая всю структуру.

Таким образом, экспоненциальный поиск удобен в ситуациях, когда границы отсортированного массива неизвестны или когда
ожидается, что искомый элемент находится ближе к началу, что позволяет быстрее сузить область поиска перед применением
бинарного метода.

## Замечание

Для работы экспоненциального поиска нам необходим бинарный поиск. Сначала необходимо реализовать бинарный поиск, а затем
использовать его в качестве подпрограммы.

## Код на Python

```python
def binary_search(arr, target, left, right):
    """
    Выполняет бинарный поиск для массива arr на отрезке [left, right] и возвращает индекс найденного элемента.
    Если элемент не найден, возвращает -1.
    """
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1


def exponential_search(arr, target):
    """
    Выполняет экспоненциальный поиск элемента target в отсортированном массиве arr.
    
    Сначала определяется диапазон, в котором может находиться target, 
    затем внутри этого диапазона выполняется бинарный поиск.
    
    Если элемент найден, возвращается его индекс, иначе -1.
    """
    if not arr:
        return -1

    # Если первый элемент равен target, возвращаем 0
    if arr[0] == target:
        return 0

    # Ищем диапазон, в котором target может находиться.
    bound = 1
    n = len(arr)
    while bound < n and arr[bound] < target:
        bound *= 2

    # Определяем границы для бинарного поиска:
    left = bound // 2
    right = min(bound, n - 1)

    # Выполняем бинарный поиск в найденном диапазоне.
    return binary_search(arr, target, left, right)


# Пример использования:
if __name__ == "__main__":
    sorted_arr = [2, 3, 4, 10, 40, 50, 60, 70, 80, 90, 100]
    target = 70
    result = exponential_search(sorted_arr, target)
    if result != -1:
        print("Элемент найден на индексе", result)
    else:
        print("Элемент не найден")
```