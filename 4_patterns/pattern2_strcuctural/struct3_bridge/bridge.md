# Bridge

## Мост

**Мост** — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные
иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

В разработке программного обеспечения часто возникает необходимость создавать системы, которые могут изменяться
независимо от других компонентов. Паттерн проектирования **Мост** (Bridge) является одним из структурных паттернов,
который помогает разделить абстракцию и её реализацию, позволяя изменять их независимо друг от друга. Это особенно
полезно в сложных системах, где требуется гибкость и расширяемость.

**Паттерн Мост** — это **структурный** паттерн проектирования, который разделяет абстракцию и реализацию таким образом,
чтобы они могли изменяться независимо друг от друга. Он достигается путем создания двух иерархий классов:

1. **Абстракция (Abstraction):** Определяет высокоуровневую часть интерфейса и содержит ссылку на объект реализации.
2. **Реализация (Implementor):** Определяет низкоуровневую часть интерфейса, которая выполняет конкретные действия.

Паттерн Мост позволяет изменять абстракции и реализации независимо, что способствует повышению гибкости и уменьшению
связанности компонентов системы.

#### Основная идея

Основная идея паттерна Мост заключается в разделении функциональности на две независимые части: абстракцию и реализацию.
Это позволяет изменять или расширять одну часть без влияния на другую.

#### Применение

Паттерн Мост рекомендуется использовать в следующих случаях:

- **Необходимо разделить абстракцию и реализацию:** Когда изменения в одной из частей не должны влиять на другую.
- **У вас есть несколько вариаций абстракций и реализаций:** Когда необходимо сочетать различные абстракции с различными
  реализациями.
- **Хотите увеличить гибкость системы:** Паттерн Мост обеспечивает возможность динамического изменения реализации во
  время выполнения.

### Реализация

1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа,
   предметная-область/ инфраструктура, фронт-энд/бэк-энд или интерфейс/ реализация.
2. Продумайте, какие операции будут нужны клиентам и опишите их в базовом классе абстракции.
3. Определите поведения доступные на всех платформах и выделите из них ту часть, которая будет нужная абстракции. На
   основании этого опишите общий интерфейс реализации
4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который
   мы выделили перед этим.
5. Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную работу
   связанному объекту реализации.
6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может
   свободно использовать объект абстракции, забыв о реализации.

### Примеры

#### [Пример](code/main.py): Создание системы фигур различного окраса

Предположим нам надо создать набор фигур (```Rectangle```, ```Triangle```) с разными
цветами (```RedColor```, ```GreenColor```, ```BlackColor```). Паттерн Мост позволит нам разделить абстракцию фигуры и
реализацию цвета, обеспечивая гибкость и расширяемость.

##### "Абстракция" - фигуры

```python
from abc import ABC, abstractmethod
from implementation import Color


# Абстракция - Shape, которая управляет раскраской через объект Color
class Shape(ABC):
    def __init__(self, color: Color) -> None:
        self.color = color

    @abstractmethod
    def draw(self) -> None:
        pass


# Уточненная абстракция - прямоугольник
class Rectangle(Shape):
    def __init__(self, color: Color) -> None:
        super().__init__(color)

    def draw(self) -> None:
        print("Drawing rectangle")
        self.color.fill_color()


# Уточненная абстракция - треугольник
class Triangle(Shape):
    def __init__(self, color: Color) -> None:
        super().__init__(color)

    def draw(self) -> None:
        print("Drawing triangle")
        self.color.fill_color()

```

##### "Реализация" - цвета

```python
from abc import ABC, abstractmethod


# Интерфейс реализации цвета ("Реализация")
class Color(ABC):
    @abstractmethod
    def fill_color(self) -> None:
        pass


# Конкретные реализации цвета
class BlackColor(Color):
    def fill_color(self) -> None:
        print("Filling in black color")


class GreenColor(Color):
    def fill_color(self) -> None:
        print("Filling in green color")


class RedColor(Color):
    def fill_color(self) -> None:
        print("Filling in red color")

```

##### Модуль для тестирования

```python
from implementation import *
from abstraction import *


# Клиентский код (аналог Main.java)
def main():
    rect = Rectangle(RedColor())
    rect.draw()

    print("---------------")

    triangle = Triangle(GreenColor())
    triangle.draw()


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Разделение абстракции и реализации:** Позволяет изменять и расширять абстракцию и реализацию независимо друг от
  друга.
- **Гибкость:** Облегчает добавление новых абстракций и реализаций без изменения существующего кода.
- **Снижение связанности:** Уменьшает зависимость между высокоуровневыми и низкоуровневыми частями системы.
- **Повторное использование кода:** Позволяет использовать одни и те же реализации с разными абстракциями и наоборот.

### Недостатки данного паттерна

- **Сложность:** Увеличивает количество классов и интерфейсов, что может усложнить понимание системы.
- **Увеличение количества кода:** Требуется дополнительный код для создания абстракций и реализаций.
- **Непрямой доступ:** Клиент может не иметь прямого доступа к методам реализации, что иногда ограничивает возможности.

### Заключение

Паттерн проектирования **Мост** является мощным инструментом для создания гибких и расширяемых систем, позволяя
разделять абстракцию и реализацию.

Понимание и правильное применение паттерна Мост способствует созданию более поддерживаемого и масштабируемого кода, что
особенно важно в больших и сложных проектах. Однако, как и любой паттерн, он должен применяться там, где это
действительно необходимо, чтобы избежать избыточной сложности системы.
