# Strategy

## Стратегия

**Паттерн Стратегия (Strategy)** — это поведенческий паттерн проектирования, который определяет семейство алгоритмов,
инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет изменять алгоритмы независимо от
клиентов, которые ими пользуются.

#### Основная идея

Паттерн Стратегия позволяет определить набор взаимозаменяемых алгоритмов, помещая их в отдельные классы, и делать их
взаимозаменяемыми во время выполнения программы. Это достигается путем использования интерфейса или абстрактного класса,
который определяет общий метод для всех алгоритмов.

#### Применение

Паттерн Стратегия рекомендуется использовать в следующих случаях:

- Необходимо выбрать один из нескольких алгоритмов в зависимости от условий во время выполнения.
- Алгоритмы часто изменяются или расширяются.
- Необходимо избежать множественных условных операторов (```if```, ```switch```) для выбора алгоритма.
- Хотите обеспечить повторное использование алгоритмов независимо от контекста.

### Реализация

1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций,
   которые выбираются во время выполнения программы.
2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
3. Поместите вариации алгоритма в собственные классы, которые реализуют этот интерфейс.
4. В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию, а также метод для её изменения.
   Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.
5. Клиенты контекста должны подавать в него соответствующий объект-стратегию, когда хотят, чтобы контекст вёл себя
   определённым образом.

### Примеры

#### [Пример](code/main.py) разных стратегий сортировки списка

Ниже приведён пример реализации паттерна «Стратегия» на Python. В этом примере есть абстрактная стратегия обработки
текста и три конкретные реализации: перевод в верхний регистр, нижний регистр и заглавные буквы каждого слова.
Класс‑контекст (TextEditor) использует выбранную стратегию для форматирования текста, а клиентский код демонстрирует
смену стратегий во время выполнения.

---

Абстрактная стратегия и разные конкретные реализации

```python
from abc import ABC, abstractmethod


# Абстрактная стратегия
class TextStrategy(ABC):
    @abstractmethod
    def format_text(self, text: str) -> str:
        pass


# Конкретная стратегия: перевод в верхний регистр
class UpperCaseStrategy(TextStrategy):
    def format_text(self, text: str) -> str:
        return text.upper()


# Конкретная стратегия: перевод в нижний регистр
class LowerCaseStrategy(TextStrategy):
    def format_text(self, text: str) -> str:
        return text.lower()


# Конкретная стратегия: каждое слово с заглавной буквы
class TitleCaseStrategy(TextStrategy):
    def format_text(self, text: str) -> str:
        return text.title()


```

---

Текстовый редактор - класс использующий разные стратегии

```python
from strategy import TextStrategy


# Контекст, использующий стратегию
class TextEditor:
    def __init__(self, strategy: TextStrategy) -> None:
        self.strategy = strategy

    def set_strategy(self, strategy: TextStrategy) -> None:
        self.strategy = strategy

    def publish_text(self, text: str) -> str:
        return self.strategy.format_text(text)
```

---

Модуль для тестирования

```python
from strategy import *
from editor import TextEditor


def main():
    text = "Hello, Strategy Pattern in Python!"

    # Используем стратегию верхнего регистра
    editor = TextEditor(UpperCaseStrategy())
    print("UpperCase:", editor.publish_text(text))

    # Смена стратегии на нижний регистр
    editor.set_strategy(LowerCaseStrategy())
    print("LowerCase:", editor.publish_text(text))

    # Смена стратегии на заглавные буквы каждого слова
    editor.set_strategy(TitleCaseStrategy())
    print("TitleCase:", editor.publish_text(text))


if __name__ == "__main__":
    main()

```

### Плюсы данного паттерна

- **Гибкость:** Позволяет легко изменять поведение объекта путем замены используемой стратегии.
- **Расширяемость:** Легко добавлять новые стратегии без изменения существующего кода.
- **Снижение связанности:** Контекст и стратегии слабо связаны, что облегчает поддержку и расширение системы.
- **Повторное использование:** Одна и та же стратегия может использоваться в разных контекстах.

### Недостатки данного паттерна

- **Увеличение числа классов:** Каждая новая стратегия требует создания отдельного класса, что может привести к
  увеличению количества классов в проекте.
- **Сложность управления стратегиями:** Необходимо обеспечить правильное управление и выбор стратегий, особенно если их
  много.
- **Потенциальные проблемы с производительностью:** Создание большого числа объектов-стратегий может привести к
  увеличению потребления памяти.

### Сравнение с другими паттернами

Паттерны **Состояние** и **Стратегия** похоже, а их UML-диаграммы по сути одинаковы.

Паттерн **Стратегия** инкапсулирует алгоритмы. Поведение объекта реализуется
различными способами: Существует множество алгоритмов для сжатия, шифрования или сортировки данных. Но
вам понадобится только один алгоритм. Поэтому из множества стратегий выберите ту.
ту, которая решает вашу задачу наиболее эффективно.

Паттерн **Состояние** используется для инкапсуляции характеристик состояния. Поведение объекта
зависит от его состояния. Когда объект находится в определенном состоянии, он ведет себя иначе, чем
когда он находится в другом состоянии.

### Заключение

**Паттерн Стратегия (Strategy)** является мощным инструментом для управления поведением объектов и выбора алгоритмов во
время выполнения программы. Он обеспечивает гибкость, расширяемость и снижает связанность между компонентами системы.

Однако, при использовании паттерна Стратегия важно учитывать его преимущества и недостатки, чтобы не создавать
избыточную структуру классов в простых системах.
