# Constraint (ограничения)

В реляционных базах данных (РБД) **constraint (ограничение)** — это правило или условие, которое задаётся для столбцов
или
таблиц, чтобы обеспечить целостность и корректность данных. Ограничения помогают предотвратить ввод неверных или
противоречивых данных. Вот основные типы ограничений и способы их реализации:

## PRIMARY KEY (Первичный ключ)

**Назначение**: Обеспечивает уникальную идентификацию каждой строки в таблице. Значение первичного ключа должно быть
уникальным и не может быть NULL.

```sql
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);
```

## FOREIGN KEY (Внешний ключ)

Устанавливает связь между таблицами, гарантируя, что значение в одном столбце соответствует значению в другой таблице.
Это обеспечивает референциальную целостность.

```sql
CREATE TABLE Orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    order_date DATE,
    CONSTRAINT fk_user
        FOREIGN KEY (user_id)
        REFERENCES Users(id)
);
```

## UNIQUE (Уникальное)

Гарантирует, что все значения в одном или нескольких столбцах будут уникальными в пределах таблицы.

```sql
CREATE TABLE Employees (
    id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE
);
```

## NOT NULL

Запрещает хранение значений ```NULL``` в столбце.

```sql
CREATE TABLE Products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price NUMERIC(10,2) NOT NULL
);
```

## CHECK

Задает условие, которому должны удовлетворять значения в столбце или таблице.

```sql
CREATE TABLE Students (
    id SERIAL PRIMARY KEY,
    age INTEGER CHECK (age >= 0),
    grade INTEGER CHECK (grade BETWEEN 1 AND 12)
);
```

## DEFAULT

Определяет значение по умолчанию, которое будет установлено в столбце, если при вставке строки не задано явное значение.

```sql
CREATE TABLE Accounts (
    id SERIAL PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'active'
);
```

## Способы реализации ограничений

- **Inline (на уровне столбца)**: Ограничение объявляется непосредственно при описании столбца.
  Например, ```username VARCHAR(50) NOT NULL UNIQUE``` объявляет, что столбец username не может содержать ```NULL``` и
  значения должны быть уникальными.
- **Table-level (на уровне таблицы)**: Ограничение определяется отдельно после описания всех столбцов. Это удобно для
  составных ключей или сложных ограничений. Например, внешний ключ или составной первичный ключ.

# Cascade (каскадное действие)

В реляционных базах данных каскадное действие (cascade) позволяет автоматически распространять изменения (удаление или
обновление) из родительской таблицы на связанные с ней записи в дочерней таблице посредством внешних ключей. Это
помогает поддерживать целостность данных, не требуя ручного обновления или удаления записей.

## Виды каскадных действия

1. **ON DELETE CASCADE** При удалении записи из родительской таблицы автоматически удаляются все записи в дочерней
   таблице, которые ссылаются на эту запись.
2. **ON UPDATE CASCADE** При обновлении значения первичного ключа в родительской таблице (что, как правило, нечасто
   происходит) автоматически обновляются все соответствующие внешние ключи в дочерней таблице.
3. **ON DELETE SET NULL** При удалении записи из родительской таблицы внешние ключи в дочерней таблице устанавливаются
   в ```NULL``` (при условии, что столбец допускает ```NULL```).
4. **ON UPDATE SET NULL** При обновлении значения в родительской таблице внешние ключи в дочерней таблице
   устанавливаются в ```NULL```.
5. **ON DELETE SET DEFAULT / ON UPDATE SET DEFAULT** При удалении или обновлении родительской записи, соответствующие
   внешние ключи в дочерней таблице устанавливаются в значение по умолчанию.
6. **ON DELETE RESTRICT / ON UPDATE RESTRICT** Запрещает удаление или обновление записи в родительской таблице, если
   существуют связанные записи в дочерней таблице.
7. **ON DELETE NO ACTION / ON UPDATE NO ACTION** По сути, похож на RESTRICT, но проверка производится в конце
   транзакции. Если нарушения ссылочной целостности обнаружены, транзакция откатывается.

## Как реализуются каскадные действия

При создании внешнего ключа в SQL можно указать нужное каскадное действие. Например, для удаления каскадом:

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    order_date DATE,
    CONSTRAINT fk_user
      FOREIGN KEY (user_id) REFERENCES users(id)
      ON DELETE CASCADE
);
```

В этом примере, если запись из таблицы ```users``` будет удалена, все заказы, связанные с этим пользователем, также
будут автоматически удалены.

Таким образом, каскадные действия (cascade) в РБД позволяют автоматически синхронизировать изменения между связанными
таблицами, что упрощает управление данными и поддержание ссылочной целостности.

# Trigger (триггер)

**Trigger (триггер)** — это специальный объект базы данных, который автоматически выполняет определённый набор команд (обычно в виде хранимой процедуры) при наступлении определённого события в базе данных (например, при вставке, обновлении или удалении строк). Триггеры используются для автоматизации задач, поддержания целостности данных, логирования изменений и реализации бизнес-логики на уровне базы данных.

## Основные типы триггеров

### По времени срабатывания

- **BEFORE trigger (до события)**: Выполняется перед основным событием. Позволяет изменить данные перед их вставкой, обновлением или удалением.
- **AFTER trigger (после события)**: Выполняется после того, как событие уже произошло. Чаще используется для логирования или выполнения действий, зависящих от уже совершённого изменения.
- **INSTEAD OF trigger**: Используется для представлений (views). Позволяет определить, что должно происходить вместо стандартного поведения, когда выполняется операция над представлением.

### По уровню срабатывания

- **Row-level trigger**: Срабатывает для каждой строки, затронутой операцией (например, каждая вставленная или обновлённая строка).
- **Statement-level trigger**: Срабатывает один раз для всего SQL-оператора, независимо от количества затронутых строк.

## Реализация триггеров в PostgreSQL

В PostgreSQL реализация триггера включает два этапа:

1. **Создание функции триггера**: Функция, написанная на PL/pgSQL (или другом поддерживаемом языке), которая будет выполняться при срабатывании триггера. Эта функция должна возвращать тип ```trigger```.
2. **Создание самого триггера**: Команда ```CREATE TRIGGER``` связывает функцию с конкретной таблицей и событием (```INSERT```, ```UPDATE```, ```DELETE```).

## Пример создания триггера

Допустим, мы хотим создать триггер, который логирует вставку новой строки в таблицу ```employees```:

1. Создаем функцию триггера:

```sql
CREATE OR REPLACE FUNCTION log_employee_insert()
RETURNS trigger AS $$
BEGIN
    -- Пример логирования: вставляем запись в таблицу log (предполагается, что такая таблица существует)
    INSERT INTO employee_log(employee_id, action, log_time)
    VALUES (NEW.id, 'INSERT', now());
    
    -- Возвращаем новую строку, которая будет вставлена в таблицу employees
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

2. Создаем триггер:

```sql
CREATE TRIGGER trg_log_employee_insert
AFTER INSERT ON employees
FOR EACH ROW
EXECUTE FUNCTION log_employee_insert();
```

- Функция ```log_employee_insert``` вызывается для каждой вставленной строки (FOR EACH ROW) после выполнения операции INSERT (AFTER INSERT).
- Внутри функции происходит вставка записи в таблицу ```employee_log``` с информацией о действии.
- Функция возвращает ```NEW```, что означает, что новая строка, прошедшая через триггер, будет сохранена в таблице ```employees```
- Команда ```CREATE TRIGGER``` связывает функцию с таблицей ```employees``` и указывает, что триггер должен срабатывать после каждой операции вставки.

