# Объектно-ориентированное программирование

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, в которой программная система моделируется как совокупность взаимодействующих объектов. Каждый объект является инкапсулированной сущностью, объединяющей в себе состояние (данные, представленные атрибутами) и поведение (функции или методы, осуществляющие операции над этими данными). Основополагающие принципы ООП – инкапсуляция, наследование, полиморфизм и абстракция – служат для распределения ответственности между компонентами системы, что способствует повышению модульности, повторному использованию кода и упрощению его сопровождения.

## Принципы ООП

- Инкапсуляция
- Наследование
- Полиморфизм
- Абстракция

## Инкапсуляция

**Инкапсуляция** – один из базовых принципов объектно-ориентированного программирования (ООП), который подразумевает объединение данных (атрибутов) и методов (функций), работающих с этими данными, внутри одного класса, а также сокрытие (скрытие) внутренней реализации от внешнего мира. Основные цели инкапсуляции:

- **Сокрытие деталей реализации**: Пользователь класса работает с его публичным интерфейсом, не вникая в детали реализации.
- **Защита данных**: Предотвращение нежелательного изменения внутренних состояний объекта.
- **Упрощение сопровождения и расширения кода**: Возможность изменения внутренней реализации без влияния на код, который использует этот класс.

В Python строгое сокрытие данных, как в некоторых других языках (например, private в Java или C++), отсутствует. Однако используются соглашения и механизмы, которые помогают реализовать инкапсуляцию:

### **Соглашение об именовании с одним подчёркиванием (```_attribute```):**

Это соглашение говорит о том, что атрибут или метод являются «защищёнными» (protected) и не предназначены для использования вне класса или его наследников. Однако на уровне языка доступ к таким атрибутам всё ещё возможен.

```Python
class Person:
    def __init__(self, name):
        self._name = name  # Атрибут помечен как "защищённый" по соглашению

    def get_name(self):
        return self._name

    def set_name(self, name):
        self._name = name

# Использование класса:
p = Person("Alice")
print(p.get_name())  # Выведет: Alice

# Несмотря на соглашение, можно обратиться напрямую:
print(p._name)  # Выведет: Alice, но делать так не рекомендуется
```

### **Манглирование имен (двойное подчёркивание ```__attribute```):**

При использовании двойного подчёркивания Python выполняет «манглирование» имени, что затрудняет случайный доступ к этим атрибутам извне. Несмотря на это, атрибут всё равно доступен (но уже через изменённое имя).

```Python
class Person:
    def __init__(self, name):
        self.__name = name  # Атрибут станет «приватным» благодаря манглированию имен

    def get_name(self):
        return self.__name

# Использование класса:
p = Person("Bob")
print(p.get_name())  # Выведет: Bob

# Попытка прямого доступа вызовет ошибку:
try:
    print(p.__name)
except AttributeError as e:
    print(e)  # Сообщение об ошибке: 'Person' object has no attribute '__name'

# Однако, благодаря манглированию, атрибут доступен через изменённое имя:
print(p._Person__name)  # Выведет: Bob

```

### **Использование свойств (```property```):**

С помощью декораторов ```@property```, ```@<имя_свойства>.setter``` и ```@<имя_свойства>.deleter``` можно управлять доступом к данным, позволяя выполнять дополнительную проверку или обработку при их получении или изменении.

Свойства позволяют инкапсулировать доступ к данным, при этом предоставляя интерфейс доступа, похожий на работу с обычными атрибутами. Это удобно, если нужно добавить валидацию или выполнить дополнительную обработку при чтении или записи значения.

```Python
class Person:
    def __init__(self, name):
        self.__name = name  # Приватный атрибут

    @property
    def name(self):
        """Геттер для атрибута name"""
        return self.__name

    @name.setter
    def name(self, value):
        """Сеттер для атрибута name с валидацией"""
        if not isinstance(value, str):
            raise ValueError("Имя должно быть строкой!")
        self.__name = value

    @name.deleter
    def name(self):
        """Делетер для атрибута name"""
        print("Удаление имени")
        del self.__name

# Использование класса:
p = Person("Charlie")
print(p.name)  # Использование геттера: Выведет "Charlie"

p.name = "Dave"  # Использование сеттера
print(p.name)    # Выведет "Dave"

# Попытка установить невалидное значение
try:
    p.name = 123
except ValueError as e:
    print(e)  # Выведет: Имя должно быть строкой!

# Удаление атрибута через делетер
del p.name
```

## Наследование

**Наследование** – один из ключевых принципов объектно-ориентированного программирования (ООП). Оно позволяет создавать новый класс (наследник или подкласс) на основе уже существующего класса (родитель или базовый класс). Это способствует повторному использованию кода, упрощает расширение функциональности и создание иерархий классов.

Основные моменты наследования в Python:

- **Передача атрибутов и методов**: Подкласс автоматически наследует все атрибуты и методы родительского класса, что позволяет не дублировать код.
- **Переопределение (override)**: Подкласс может переопределять (изменять) методы родительского класса для предоставления своей реализации.
- **Расширение функциональности**: В подклассе можно добавлять новые атрибуты и методы помимо тех, что были у родительского класса.
- **Множественное наследование**: Python позволяет классу наследовать поведение сразу от нескольких родительских классов. В этом случае используется механизм разрешения порядка методов (MRO — Method Resolution Order).

### Простой пример наследования

Предположим, у нас есть базовый класс ```Animal```, от которого будут наследоваться классы животных.

```Python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "..."

# Класс Dog наследует класс Animal
class Dog(Animal):
    def speak(self):
        return "Woof!"

# Класс Cat наследует класс Animal
class Cat(Animal):
    def speak(self):
        return "Meow!"

# Использование классов:
dog = Dog("Buddy")
cat = Cat("Whiskers")

print(f"{dog.name} говорит: {dog.speak()}")  # Выведет: Buddy говорит: Woof!
print(f"{cat.name} говорит: {cat.speak()}")  # Выведет: Whiskers говорит: Meow!
```

### Переопределение методов и использование ```super()```

Иногда необходимо расширить функциональность родительского класса, добавив дополнительные атрибуты или изменив поведение методов. При этом может понадобиться вызвать реализацию метода из родительского класса. Для этого используется функция super()

```Python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        return f"Меня зовут {self.name} и мне {self.age} лет."

class Student(Person):
    def __init__(self, name, age, university):
        # Вызов конструктора родительского класса для инициализации name и age
        super().__init__(name, age)
        self.university = university

    def introduce(self):
        # Расширяем поведение метода introduce() родительского класса
        base_introduction = super().introduce()
        return f"{base_introduction} Я учусь в {self.university}."

# Использование классов:
student = Student("Алексей", 21, "МГУ")
print(student.introduce())
# Выведет: Меня зовут Алексей и мне 21 лет. Я учусь в МГУ.
```

В этом примере класс ```Student``` расширяет класс Person, добавляя атрибут ```university``` и переопределяя метод ```introduce()```, при этом вызывая родительскую версию этого метода с помощью ```super()```.

### Множественное наследование и разрешение порядка методов (MRO)

Python позволяет создавать классы, наследующиеся сразу от нескольких родительских классов. Это называется множественным наследованием. В таких случаях важно понимать, какой метод будет вызван, если имена методов совпадают в разных родительских классах. Для этого Python использует механизм MRO.

```Python
class A:
    def method(self):
        print("Метод из класса A")

class B:
    def method(self):
        print("Метод из класса B")

class C(A, B):
    pass

c = C()
c.method()  # Какой метод будет вызван?
```

В данном случае класс ```C``` наследует сначала от класса ```A```, затем от класса ```B```. При вызове ```c.method()``` Python сначала ищет метод в классе ```C```, затем в классе ```A```, и только потом в классе ```B```. Таким образом, выведется:

```Python
Метод из класса A
```

Вы можете посмотреть порядок разрешения методов, используя атрибут ```__mro__``` или функцию ```mro()```:

```Python
print(C.__mro__)
# Выведет что-то вроде: (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

## Полиморфизм

**Полиморфизм** – один из ключевых принципов объектно-ориентированного программирования (ООП). Он позволяет объектам разных классов реагировать на одинаковые сообщения (вызовы методов) по-разному. Другими словами, полиморфизм обеспечивает единообразный интерфейс для работы с объектами, независимо от их конкретного типа.

### Основные аспекты полиморфизма в Python

1. **Переопределение методов (Method Overriding):** Когда подкласс предоставляет свою реализацию метода, который уже определён в базовом классе, это и есть полиморфизм. Вызов метода происходит через объект, и в зависимости от того, к какому классу он принадлежит, будет вызвана соответствующая реализация.
2. **Duck Typing:** Принцип «уткиного типизирования» («if it walks like a duck and quacks like a duck, it’s a duck») позволяет не заботиться о типе объекта, а лишь о наличии необходимых методов или атрибутов. Это означает, что объекты, не обязательно имеющие общую иерархию, могут использоваться взаимозаменяемо, если они реализуют нужный интерфейс.
3. **Перегрузка операторов:** В Python можно перегружать операторы (например, ```+```, ```-```, ```*``` и т.д.) посредством реализации специальных методов (например, ```__add__```, ```__sub__``` и т.д.). Это тоже разновидность полиморфизма, так как один и тот же оператор может работать по-разному для разных типов данных.

### Пример 1. Полиморфизм через переопределение методов

```Python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        # Абстрактный метод – предполагается, что наследники реализуют свою версию
        raise NotImplementedError("Подкласс должен реализовать этот метод")

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# Создаем список объектов разных типов, но все они являются животными
animals = [Dog("Buddy"), Cat("Whiskers")]

for animal in animals:
    # Вызов метода speak() приводит к выполнению своей реализации для каждого объекта
    print(f"{animal.name} говорит: {animal.speak()}")
```

Классы ```Dog``` и ```Cat``` переопределяют метод ```speak()``` базового класса ```Animal```. При вызове ```speak()``` на объектах из списка ```animals``` происходит динамическое определение нужного метода в зависимости от типа объекта.

### Пример 2. Полиморфизм с использованием duck typing

```Python
class Duck:
    def quack(self):
        print("Quack, quack!")

class Person:
    def quack(self):
        print("I'm imitating a duck!")

def make_it_quack(entity):
    # Неважно, какого типа объект, главное – наличие метода quack()
    entity.quack()

duck = Duck()
person = Person()

make_it_quack(duck)    # Выведет: Quack, quack!
make_it_quack(person)  # Выведет: I'm imitating a duck!
```

Функция ```make_it_quack``` не проверяет тип переданного объекта, а просто вызывает метод ```quack()```. Благодаря duck typing, если объект реализует метод ```quack()```, он подходит для использования в этой функции, даже если объекты ```Duck``` и ```Person``` не связаны общей иерархией.

### Пример 3. Полиморфизм через перегрузку операторов

```Python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        # Перегружаем оператор сложения для объектов Vector
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        raise ValueError("Operand must be of type Vector")

    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)  # Выведет: Vector(4, 6)
```

Метод ```__add__``` перегружает оператор + для объектов класса Vector. Это позволяет складывать векторы посредством оператора ```+```, что является формой полиморфизма на уровне операций.

## Абстракция

**Абстракция** – один из фундаментальных принципов объектно-ориентированного программирования (ООП), позволяющий выделять суть объекта, скрывая его сложную внутреннюю реализацию. Другими словами, абстракция позволяет сконцентрироваться на том, что делает объект (его интерфейс), а не на том, как он это делает (его реализация).

### Основные моменты абстракции

- **Сокрытие деталей реализации:** Пользователь класса работает через его интерфейс, не вникая в детали работы.
- **Определение общего поведения:** Абстрактные классы и методы задают контракт для всех наследников, которые обязаны реализовать определённое поведение.
- **Повышение гибкости и расширяемости:** При изменении внутренней реализации абстракции не меняется интерфейс, что облегчает сопровождение и модификацию кода.

В Python абстракцию можно реализовать следующим способом:

**Абстрактные базовые классы (Abstract Base Classes, ABC)**:
Модуль ```abc``` позволяет создавать классы, содержащие абстрактные методы, которые должны быть реализованы в подклассах. Такой подход задаёт формальный контракт для наследников.

### Пример использования абстрактных базовых классов

В данном примере мы создадим абстрактный класс ```Shape```, который задаёт контракт для всех фигур (вычисление площади и периметра). Конкретные классы, такие как ```Rectangle``` и ```Circle```, реализуют эти методы.

```Python
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self):
        """Вычисляет площадь фигуры"""
        pass

    @abstractmethod
    def perimeter(self):
        """Вычисляет периметр фигуры"""
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

    def perimeter(self):
        return 2 * math.pi * self.radius

# Создание экземпляров конкретных фигур
rectangle = Rectangle(3, 4)
circle = Circle(5)

print(f"Прямоугольник: площадь = {rectangle.area()}, периметр = {rectangle.perimeter()}")
print(f"Круг: площадь = {circle.area():.2f}, периметр = {circle.perimeter():.2f}")
```

- **Абстрактный класс Shape:** Объявляет два абстрактных метода ```area()``` и ```perimeter()```. Попытка создать экземпляр ```Shape``` приведёт к ошибке, поскольку не все абстрактные методы реализованы.
- **Классы Rectangle и Circle:** Наследуют ```Shape``` и обязаны реализовать методы ```area()``` и ```perimeter()```. Таким образом, любой объект, являющийся потомком ```Shape```, гарантированно поддерживает заданный интерфейс.
