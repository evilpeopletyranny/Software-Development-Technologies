# Memento

## Снимок

**Снимок** — это поведенческий паттерн проектирования, который позволяет делать снимки состояния объектов, не раскрывая
подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов.

#### Основная идея

Паттерн Снимок отделяет объект, сохраняющий состояние (Снимок), от объекта, чей статус сохраняется (Происхождение).
Таким образом, Происхождение может создавать Снимки, чтобы сохранить свое состояние, а затем использовать их для
восстановления этого состояния без раскрытия внутренней структуры.

#### Применение

Паттерн Снимок рекомендуется использовать в следующих случаях:

- **Необходимо сохранить предыдущее состояние объекта:** Когда требуется иметь возможность вернуть объект к предыдущему
  состоянию (например, в редакторах с функцией отмены).
- **Хранение истории изменений:** Для реализации журналов или историй изменений.
- **Избегание нарушения инкапсуляции:** Когда необходимо сохранять состояние объекта без раскрытия его внутренней
  структуры.

### Реализация

1. Определите класс создателя, объекты которого должны создавать снимки своего состояния.
2. Создайте класс снимка и опишите в нём все те же поля, которые имеются в оригинальном классе-создателе.
3. Сделайте объекты снимков неизменяемыми. Они должны получать начальные значения только один раз, через свой
   конструктор.
4. Если ваш язык программирования это позволяет, сделайте класс снимка вложенным в класс создателя.
5. Добавьте в класс создателя метод получения снимков. Создатель должен создавать новые объекты снимков, передавая
   значения своих полей через конструктор.
6. Добавьте в класс создателя метод восстановления из снимка.
7. Опекуны, будь то история операций, объекты команд или нечто иное, должны знать о том, когда запрашивать снимки у
   создателя, где их хранить, и когда восстанавливать.
8. Связь опекунов с создателями можно перенести внутрь снимков. В этом случае каждый снимок будет привязан к своему
   создателю и должен будет сам восстанавливать его состояние. Но это будет работать либо если классы снимков вложены в
   классы создателей, либо если создатели имеют сеттеры для установки значений своих полей.

### Примеры

#### [Пример](code%2Fexample2_game_state%2FMain.java) с сохранением состояния игры

```Game```: Класс, представляющий игру. Методы ```move_player()``` и ```add_score()``` изменяют состояние
игры, ```save()``` возвращает снимок текущего состояния, а ```restore()``` восстанавливает состояние из переданного
снимка.

```python
class Game:
    def __init__(self) -> None:
        self.player_position = 0
        self.score = 0

    def move_player(self, new_position: int) -> None:
        self.player_position = new_position
        print(f"Player moved to position: {self.player_position}")

    def add_score(self, points: int) -> None:
        self.score += points
        print(f"Score increased by {points}. Current score: {self.score}")

    def save(self) -> GameState:
        print(f"Saving game state: Position={self.player_position}, Score={self.score}")
        return GameState(self.player_position, self.score)

    def restore(self, state: GameState) -> None:
        self.player_position = state.player_position
        self.score = state.score
        print(f"Game state restored: Position={self.player_position}, Score={self.score}")
```

---

```GameState```: **Класс-«снимок»**, который сохраняет позицию игрока и счёт.

```python
class GameState:
    def __init__(self, player_position: int, score: int) -> None:
        self.player_position = player_position
        self.score = score

    def __repr__(self) -> str:
        return f"GameState(Position={self.player_position}, Score={self.score})"
```

---

```GameSaveManager```: Управляет историей сохранённых состояний (используется список как стек).
Методы ```save_state()```
сохраняют снимок, а ```restore_state()``` извлекают последний снимок и восстанавливают состояние игры.

```python
class GameSaveManager:
    def __init__(self) -> None:
        self.save_stack = []

    def save_state(self, game: Game) -> None:
        self.save_stack.append(game.save())

    def restore_state(self, game: Game) -> None:
        if self.save_stack:
            state = self.save_stack.pop()
            game.restore(state)
        else:
            print("No saved states to restore.")
```

---

```main()```: Демонстрирует изменение состояния игры, сохранение состояний, их восстановление и обработку случая, когда
история пуста.

```python
def main():
    game = Game()
    save_manager = GameSaveManager()

    # Изменяем состояние игры и сохраняем его
    game.move_player(10)
    game.add_score(50)
    save_manager.save_state(game)

    game.move_player(20)
    game.add_score(30)
    save_manager.save_state(game)

    game.move_player(30)
    game.add_score(20)
    print(f"Current Game State: Position={game.player_position}, Score={game.score}")

    print("\nRestoring to last saved state:")
    save_manager.restore_state(game)
    print(f"Game State after restoration: Position={game.player_position}, Score={game.score}")

    print("\nRestoring to previous saved state:")
    save_manager.restore_state(game)
    print(f"Game State after restoration: Position={game.player_position}, Score={game.score}")

    print("\nAttempting to restore beyond history:")
    save_manager.restore_state(game)


if __name__ == "__main__":
    main()
```

### Плюсы данного паттерна

- **Легкость реализации механизмов отмены и повторения:** Обеспечивает простой способ отката к предыдущим состояниям.
- **Гибкость управления историей состояний:** Можно реализовать сложные механизмы истории, такие как множественные
  уровни отмены или линейное и ветвящееся восстановление.
- **Повторное использование объектов Memento:** Один и тот же объект снимка может использоваться разными объектами (
  например перенос сохранений с одной машины на другую).

### Недостатки данного паттерна

- **Увеличение использования памяти:** Хранение многочисленных состояний может потребовать значительного объема памяти.
- **Сложность реализации:** Требует дополнительного проектирования и создания дополнительных классов (Memento).
- **Управление жизненным циклом состояний:** Необходимо контролировать сохранение и удаление состояний, чтобы избежать
  утечек памяти.

### Заключение

Паттерн Снимок (Memento) является мощным инструментом для управления состоянием объектов, особенно когда требуется
реализовать механизмы отмены и восстановления. Он позволяет сохранять состояние объекта без раскрытия его внутренней
структуры, обеспечивая при этом гибкость и расширяемость системы.

Однако, при использовании паттерна Снимок важно учитывать потенциальные недостатки, такие как увеличение использования
памяти и сложность реализации. Правильное управление жизненным циклом состояний и минимизация объема сохраняемых данных
помогут эффективно использовать этот паттерн в ваших проектах.
